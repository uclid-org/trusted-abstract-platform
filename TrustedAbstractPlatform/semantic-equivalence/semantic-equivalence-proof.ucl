module semantic_equivalence_proof {

type * = proof_common.*;
const * = proof_common.*;
function * = proof_common.*;
define * = proof_common.*;

instance s_tap: single_region_tap();
instance f_tap: faas_tap();


procedure ProveSemanticEquivalence()
    modifies s_tap;
    modifies f_tap;
{
    var eid, p_eid, r_eid, r_parent_eid, c_eid        : tap_enclave_id_t;
    var status, status_1, status_2                    : enclave_op_result_t;
    var e_addr_valid                                  : addr_valid_t;
    var e_addr_map                                    : addr_map_t;
    var e_excl_vaddr                                  : excl_vaddr_t;
    var e_excl_map, p_e_excl_map, c_e_excl_map        : excl_map_t;
    var e_bounds, p_e_bounds, c_e_bounds              : bounds_t;
    var e_container_data                              : container_data_t;
    var e_entrypoint                                  : vaddr_t;
    var e_proof_op, r_proof_op                        : tap_proof_op_t;
    var r_regs                                        : regs_t;
    var current_mode_1, current_mode_2, current_mode  : mode_t;
    var enclave_dead, done                            : boolean;
    var r_paddr                                       : wap_addr_t;
    var r_word                                        : word_t;
    var vaddr_1, vaddr_2                              : vaddr_t;
    var paddr_1, paddr_2                              : wap_addr_t;
    var data_1, data_2                                : word_t;
    var iter                                          : integer;

    assume (c_eid != eid && c_eid != p_eid);


    // launch the same enclave in both traces.
    call (current_mode_1) = s_tap.InitialHavoc();
    call s_tap.InitOSMem(e_excl_map, e_container_data);

    call (current_mode_2) = f_tap.InitialHavoc();
    call f_tap.InitOSMem(e_excl_map, e_container_data);


    // Launch the enclave normally
    call (status_1) = s_tap.launch(eid, e_addr_valid, e_addr_map, e_excl_vaddr, e_excl_map, e_bounds, e_entrypoint);
    assume status_1 == enclave_op_success;
    assert (s_tap.tap_enclave_metadata_bounds_valid[eid] == true);
    assert (s_tap.tap_enclave_metadata_region_bounds[eid] == e_bounds);

    call (status_2) = f_tap.launch(eid, e_addr_valid, e_addr_map, e_excl_vaddr, e_excl_map, e_bounds, e_entrypoint);
    assume status_2 == enclave_op_success;
    assert (f_tap.tap_enclave_metadata_bounds_valid[eid] == true);
    assert (f_tap.tap_enclave_metadata_region_bounds[eid] == e_bounds);




    assert (f_tap.tap_enclave_metadata_is_snapshot[eid] == false);

    assert (s_tap.tap_enclave_metadata_bounds_valid[eid] == f_tap.tap_enclave_metadata_bounds_valid[eid]);
    assert (s_tap.tap_enclave_metadata_region_bounds[eid] == f_tap.tap_enclave_metadata_region_bounds[eid]);
    assert s_tap.tap_enclave_metadata_valid[eid] == f_tap.tap_enclave_metadata_valid[eid];
    assert s_tap.tap_enclave_metadata_addr_map[eid] == f_tap.tap_enclave_metadata_addr_map[eid];
    assert s_tap.tap_enclave_metadata_addr_valid[eid] == f_tap.tap_enclave_metadata_addr_valid[eid];
    assert s_tap.tap_enclave_metadata_addr_excl[eid] == f_tap.tap_enclave_metadata_addr_excl[eid];
    assert s_tap.tap_enclave_metadata_entrypoint[eid] == f_tap.tap_enclave_metadata_entrypoint[eid];
    assert s_tap.tap_enclave_metadata_pc[eid] == f_tap.tap_enclave_metadata_pc[eid];
    assert s_tap.tap_enclave_metadata_regs[eid] == f_tap.tap_enclave_metadata_regs[eid];
    assert s_tap.tap_enclave_metadata_paused[eid] == f_tap.tap_enclave_metadata_paused[eid];
    assert s_tap.tap_enclave_metadata_cache_conflict[eid] == f_tap.tap_enclave_metadata_cache_conflict[eid];
    assert s_tap.tap_enclave_metadata_region_bounds[eid] == f_tap.tap_enclave_metadata_region_bounds[eid];
    assert s_tap.tap_enclave_metadata_bounds_valid[eid] == f_tap.tap_enclave_metadata_bounds_valid[eid];



    // sanity check.
    assert current_mode_1 == mode_untrusted;
    assert current_mode_2 == mode_untrusted;
    current_mode = current_mode_1;
    // main loop.
    enclave_dead = false;

    //assert(false);

    assume (r_eid != eid || r_proof_op != tap_proof_op_destroy);
    assume (r_eid != c_eid); // Leave this open

    // execute the operation in trace_1
    call (current_mode, enclave_dead) = s_tap.IntegrityAdversarialStep(
            mode_untrusted, eid, r_eid, r_parent_eid, r_regs, r_proof_op);


    // if the mode changed, we need to do this in trace_2
    if (current_mode == mode_enclave) {
        call (current_mode, enclave_dead) = f_tap.IntegrityAdversarialStep(
                mode_enclave, eid, r_eid, r_parent_eid, r_regs, r_proof_op);
        // sanity check.
        assert current_mode == mode_enclave;
        assert (s_tap.cpu.cpu_enclave_id == eid && f_tap.cpu.cpu_enclave_id == eid); // Sanity check
        assert !enclave_dead;

        
        //assert(false);
    }

    assert (s_tap.tap_enclave_metadata_bounds_valid[eid] == f_tap.tap_enclave_metadata_bounds_valid[eid]);
    assert (s_tap.tap_enclave_metadata_region_bounds[eid] == f_tap.tap_enclave_metadata_region_bounds[eid]);


    //assert(false);


    done = false;
    while (!done) 
        //----------------------------------------------------------------------//
        // global TAP invariants.                                               //
        //----------------------------------------------------------------------//
        invariant  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                    (valid_enclave_id(e) && !s_tap.tap_enclave_metadata_valid[e]) ==> 
                        (s_tap.cpu.cpu_owner_map[pa] != e));
        invariant  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                    (valid_enclave_id(e) && !f_tap.tap_enclave_metadata_valid[e]) ==> 
                        (f_tap.cpu.cpu_owner_map[pa] != e));
        invariant (forall (pa: wap_addr_t, e : tap_enclave_id_t) ::
                    f_tap.tap_enclave_metadata_wap_addr_free[e][pa] ==> f_tap.cpu.cpu_owner_map[pa] == e);
        invariant (forall (e: tap_enclave_id_t) :: f_tap.tap_enclave_metadata_child_count[e] >= 0);

        // Stuff to show semantic equivalence
        invariant s_tap.tap_enclave_metadata_valid[eid] == f_tap.tap_enclave_metadata_valid[eid];
        invariant (forall (va : vaddr_t) :: s_tap.tap_enclave_metadata_addr_excl[eid][va] ==> s_tap.tap_enclave_metadata_addr_map[eid][va] == f_tap.tap_enclave_metadata_addr_map[eid][va]);
        invariant (forall (va : vaddr_t) :: s_tap.tap_enclave_metadata_addr_excl[eid][va] ==> s_tap.tap_enclave_metadata_addr_valid[eid][va] == f_tap.tap_enclave_metadata_addr_valid[eid][va]);
        invariant s_tap.tap_enclave_metadata_addr_excl[eid] == f_tap.tap_enclave_metadata_addr_excl[eid];
        invariant s_tap.tap_enclave_metadata_entrypoint[eid] == f_tap.tap_enclave_metadata_entrypoint[eid];
        invariant s_tap.tap_enclave_metadata_pc[eid] == f_tap.tap_enclave_metadata_pc[eid];
        invariant s_tap.tap_enclave_metadata_regs[eid] == f_tap.tap_enclave_metadata_regs[eid];
        invariant s_tap.tap_enclave_metadata_paused[eid] == f_tap.tap_enclave_metadata_paused[eid];
        invariant s_tap.tap_enclave_metadata_cache_conflict[eid] == f_tap.tap_enclave_metadata_cache_conflict[eid];
        invariant s_tap.tap_enclave_metadata_region_bounds[eid] == f_tap.tap_enclave_metadata_region_bounds[eid];
        invariant s_tap.tap_enclave_metadata_bounds_valid[eid] == f_tap.tap_enclave_metadata_bounds_valid[eid];

        // Extra stuff
        invariant (current_mode == mode_enclave ==> tap_addr_perm_x(s_tap.cpu.cpu_addr_valid[s_tap.cpu.cpu_pc]));
        invariant (current_mode == mode_enclave ==> s_tap.tap_enclave_metadata_addr_excl[eid][s_tap.cpu.cpu_pc]);
        invariant (current_mode == mode_enclave ==> s_tap.cpu.cpu_owner_map[s_tap.cpu.cpu_addr_map[s_tap.cpu.cpu_pc]] == eid);
        invariant (current_mode == mode_enclave ==> tap_addr_perm_x(f_tap.cpu.cpu_addr_valid[f_tap.cpu.cpu_pc]));
        invariant (current_mode == mode_enclave ==> f_tap.tap_enclave_metadata_addr_excl[eid][f_tap.cpu.cpu_pc]);
        invariant (current_mode == mode_enclave ==> f_tap.cpu.cpu_owner_map[f_tap.cpu.cpu_addr_map[f_tap.cpu.cpu_pc]] == eid);

        // eid is valid.
    invariant valid_enclave_id(eid); 
    invariant !enclave_dead ==>
                (s_tap.tap_enclave_metadata_valid[eid] && f_tap.tap_enclave_metadata_valid[eid]);
    // cpu.cpu_enclave_id is never blocked_enclave_id
    invariant (s_tap.cpu.cpu_enclave_id != tap_blocked_enc_id);
    invariant (f_tap.cpu.cpu_enclave_id != tap_blocked_enc_id);
    // the entrypoint always has an executable vaddr -> paddr mapping.
    invariant !enclave_dead ==>
                tap_addr_perm_x(s_tap.tap_enclave_metadata_addr_valid[eid][s_tap.tap_enclave_metadata_entrypoint[eid]]);
    invariant !enclave_dead ==>
                tap_addr_perm_x(f_tap.tap_enclave_metadata_addr_valid[eid][f_tap.tap_enclave_metadata_entrypoint[eid]]);
    invariant !enclave_dead ==>
                s_tap.tap_enclave_metadata_addr_excl[eid][s_tap.tap_enclave_metadata_entrypoint[eid]];
    invariant !enclave_dead ==>
                f_tap.tap_enclave_metadata_addr_excl[eid][f_tap.tap_enclave_metadata_entrypoint[eid]];
    // the pc always has an executable vaddr -> paddr mapping. 
    invariant !enclave_dead ==>
                tap_addr_perm_x(s_tap.tap_enclave_metadata_addr_valid[eid][s_tap.tap_enclave_metadata_pc[eid]]);
    invariant !enclave_dead ==>
                tap_addr_perm_x(f_tap.tap_enclave_metadata_addr_valid[eid][f_tap.tap_enclave_metadata_pc[eid]]);
    invariant !enclave_dead ==>
                s_tap.tap_enclave_metadata_addr_excl[eid][s_tap.tap_enclave_metadata_pc[eid]];
    invariant !enclave_dead ==>
                f_tap.tap_enclave_metadata_addr_excl[eid][f_tap.tap_enclave_metadata_pc[eid]];
    // the cpu.cpu_owner_map and enclave's excl_map are consistent.
    invariant (forall (pa: wap_addr_t) :: 
                !enclave_dead ==> (s_tap.cpu.cpu_owner_map[pa] == eid <==> e_excl_map[pa]));
    invariant (forall (pa: wap_addr_t) :: 
                !enclave_dead ==> (f_tap.cpu.cpu_owner_map[pa] == eid <==> e_excl_map[pa]));
    invariant (!enclave_dead) ==>
                 (s_tap.tap_enclave_metadata_addr_excl[eid] == e_excl_vaddr);
    invariant (!enclave_dead) ==>
                 (f_tap.tap_enclave_metadata_addr_excl[eid] == e_excl_vaddr);
    invariant (!enclave_dead) ==>
                 (s_tap.tap_enclave_metadata_bounds_valid[eid] == f_tap.tap_enclave_metadata_bounds_valid[eid]);
    invariant (!enclave_dead) ==>
                 (s_tap.tap_enclave_metadata_region_bounds[eid] == f_tap.tap_enclave_metadata_region_bounds[eid]);

     // invariants about the states of the CPUs.
    // are we in attacker mode?
    invariant (current_mode == mode_untrusted) ==> (s_tap.cpu.cpu_enclave_id != eid);
    invariant (current_mode == mode_untrusted) ==> (f_tap.cpu.cpu_enclave_id == tap_null_enc_id);
    // if we are in trusted mode, we mean our enclave. 
    invariant (current_mode == mode_enclave ==> 
                (s_tap.cpu.cpu_enclave_id == eid  && f_tap.cpu.cpu_enclave_id == eid));
    invariant current_mode == mode_enclave ==> s_tap.cpu.cpu_enclave_id == eid;
    invariant current_mode == mode_enclave ==> f_tap.cpu.cpu_enclave_id == eid;
    // the CPU state is also the same in trusted mode.
    invariant (current_mode == mode_enclave ==> s_tap.cpu.cpu_pc == f_tap.cpu.cpu_pc);
    invariant (current_mode == mode_enclave ==> tap_addr_perm_x(s_tap.cpu.cpu_addr_valid[s_tap.cpu.cpu_pc]));
    invariant (current_mode == mode_enclave ==> tap_addr_perm_x(f_tap.cpu.cpu_addr_valid[f_tap.cpu.cpu_pc]));
    invariant (current_mode == mode_enclave ==> s_tap.tap_enclave_metadata_addr_excl[eid][s_tap.cpu.cpu_pc]);
    invariant (current_mode == mode_enclave ==> f_tap.tap_enclave_metadata_addr_excl[eid][f_tap.cpu.cpu_pc]);
    invariant (current_mode == mode_enclave ==> s_tap.cpu.cpu_owner_map[s_tap.cpu.cpu_addr_map[s_tap.cpu.cpu_pc]] == eid);
    invariant (current_mode == mode_enclave ==> f_tap.cpu.cpu_owner_map[f_tap.cpu.cpu_addr_map[f_tap.cpu.cpu_pc]] == eid);
    // if we are in trusted mode, then metadata and CPU state are the same.
    invariant (forall (ri : regindex_t) ::
                (current_mode == mode_enclave) ==>
                    (s_tap.cpu.cpu_regs[ri] == f_tap.cpu.cpu_regs[ri]));
    // This states that the two traces update addr_valid in the same way.
    invariant (forall (va : vaddr_t) ::
                (current_mode == mode_enclave && e_excl_vaddr[va]) ==>
                    (s_tap.cpu.cpu_addr_valid[va] == f_tap.cpu.cpu_addr_valid[va]));
    // But note cpu.cpu_addr_valid may differ from the tap_enclave_metadata_addr_valid because 
    // the accessed bit is set in the form.
    //invariant (forall (va : vaddr_t) ::
    //            (current_mode == mode_enclave) ==>
    //                tap_addr_perm_eq(s_tap.tap_enclave_metadata_addr_valid[eid][va], s_tap.cpu.cpu_addr_valid[va]));
    invariant (forall (va : vaddr_t) ::
                (current_mode == mode_enclave) ==>
                    tap_addr_perm_eq(f_tap.tap_enclave_metadata_addr_valid[eid][va], f_tap.cpu.cpu_addr_valid[va]));
    invariant (forall (va : vaddr_t) ::
                (current_mode == mode_enclave && e_excl_vaddr[va]) ==>
                    (e_addr_map[va] == s_tap.cpu.cpu_addr_map[va]));
    invariant (forall (va : vaddr_t) ::
                (current_mode == mode_enclave && e_excl_vaddr[va]) ==>
                    (e_addr_map[va] == f_tap.cpu.cpu_addr_map[va]));



        invariant enclave_dead == false;
    {
        havoc r_eid; havoc r_proof_op; havoc e_proof_op; havoc r_regs; havoc r_parent_eid;
        assume (r_eid != c_eid);
        if (current_mode == mode_untrusted) {
            var old_cpu_enclave_id_1 : tap_enclave_id_t;
            old_cpu_enclave_id_1 = s_tap.cpu.cpu_enclave_id;

            assume (r_eid != eid || r_proof_op != tap_proof_op_destroy);

            // execute the operation in trace_1
            call (current_mode, enclave_dead) = s_tap.IntegrityAdversarialStep(
                    mode_untrusted, eid, r_eid, r_parent_eid, r_regs, r_proof_op);


            // if the mode changed, we need to do this in trace_2
            if (current_mode == mode_enclave) {
                assert (r_proof_op == tap_proof_op_enter || r_proof_op == tap_proof_op_resume);
                assert (r_eid == eid);
                call (current_mode, enclave_dead) = f_tap.IntegrityAdversarialStep(
                        mode_enclave, eid, r_eid, r_parent_eid, r_regs, r_proof_op);
                // sanity check.
                assert current_mode == mode_enclave;
                assert (s_tap.cpu.cpu_enclave_id == eid && f_tap.cpu.cpu_enclave_id == eid); // Sanity check
                assert !enclave_dead;
                //assert(false);
            } else {
                havoc done;
            }
            //assert(false);
        } else {
            if (current_mode == mode_enclave) {
                assert (s_tap.cpu.cpu_enclave_id == eid && f_tap.cpu.cpu_enclave_id == eid); // Sanity check
                havoc iter;

                assume standard_tap_proof_op_valid_in_enclave(e_proof_op);
                assume e_proof_op != tap_proof_op_snapshot; // No snapshot yet
                

                // enclave step in trace_1
                call (current_mode_1, vaddr_1, paddr_1, data_1) = s_tap.IntegrityEnclaveStep(
                                                                e_proof_op, iter);

                // enclave step in trace_2
                call (current_mode_2, vaddr_2, paddr_2, data_2) = f_tap.IntegrityEnclaveStep(
                                                                e_proof_op, iter);
                assert(current_mode_1 == current_mode_2);
                current_mode = current_mode_1;
                assert vaddr_1 == vaddr_2;
                assert data_1 == data_2;
                //assert(false);
            }
            //assert(false);
        }
        //assert(false);


    }

    //assert(false);
    assert (current_mode != mode_enclave);



    if (s_tap.cpu.cpu_enclave_id != tap_null_enc_id) {
        call (status) = s_tap.pause();
        assert status == enclave_op_success;
    }

    if (f_tap.cpu.cpu_enclave_id != tap_null_enc_id) {
        call (status) = f_tap.pause();
        assert status == enclave_op_success;
    }

    call (status) = f_tap.enter(eid);
    assume (status == enclave_op_success);
    //assert(false);
    
    call (status) = f_tap.snapshot();
    assume status == enclave_op_success;
    //assert(false);


    call (status_1) = f_tap.clone(c_eid, eid, c_e_excl_map, c_e_bounds);

    //assert(false);
    assert (status_1 != enclave_op_success);
    assume status_1 == enclave_op_success;

    //assert (false);
    assert(enclave_dead == false);


    havoc r_eid; havoc r_proof_op; havoc e_proof_op; havoc r_regs; havoc r_parent_eid;
    // execute the operation in trace_1
    call (current_mode, enclave_dead) = s_tap.IntegrityAdversarialStep(
            mode_untrusted, eid, r_eid, r_parent_eid, r_regs, r_proof_op);


    // if the mode changed, we need to do this in trace_2
    if (current_mode == mode_enclave) {
        call (current_mode, enclave_dead) = f_tap.IntegrityAdversarialStep(
                mode_enclave, c_eid, c_eid, r_parent_eid, r_regs, r_proof_op);
        // sanity check.
        assert current_mode == mode_enclave;
        assert (s_tap.cpu.cpu_enclave_id == eid && f_tap.cpu.cpu_enclave_id == c_eid); // Sanity check
        assert !enclave_dead;

        
        //assert(false);
    }

    //assert(false);



    while (!enclave_dead) 
        //----------------------------------------------------------------------//
        // global TAP invariants.                                               //
        //----------------------------------------------------------------------//
        invariant  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                    (valid_enclave_id(e) && !s_tap.tap_enclave_metadata_valid[e]) ==> 
                        (s_tap.cpu.cpu_owner_map[pa] != e));
        invariant  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                    (valid_enclave_id(e) && !f_tap.tap_enclave_metadata_valid[e]) ==> 
                        (f_tap.cpu.cpu_owner_map[pa] != e));
        invariant (forall (pa: wap_addr_t, e : tap_enclave_id_t) ::
                    f_tap.tap_enclave_metadata_wap_addr_free[e][pa] ==> f_tap.cpu.cpu_owner_map[pa] == e);
        invariant (forall (e: tap_enclave_id_t) :: f_tap.tap_enclave_metadata_child_count[e] >= 0);

        // Stuff to show semantic equivalence
        invariant s_tap.tap_enclave_metadata_valid[eid] == f_tap.tap_enclave_metadata_valid[c_eid];
        invariant (forall (va : vaddr_t) :: s_tap.tap_enclave_metadata_addr_excl[eid][va] ==> s_tap.tap_enclave_metadata_addr_map[eid][va] == f_tap.tap_enclave_metadata_addr_map[c_eid][va]);
        invariant (forall (va : vaddr_t) :: s_tap.tap_enclave_metadata_addr_excl[eid][va] ==> s_tap.tap_enclave_metadata_addr_valid[eid][va] == f_tap.tap_enclave_metadata_addr_valid[c_eid][va]);
        invariant s_tap.tap_enclave_metadata_addr_excl[eid] == f_tap.tap_enclave_metadata_addr_excl[c_eid];
        invariant s_tap.tap_enclave_metadata_entrypoint[eid] == f_tap.tap_enclave_metadata_entrypoint[c_eid];
        invariant s_tap.tap_enclave_metadata_pc[eid] == f_tap.tap_enclave_metadata_pc[c_eid];
        invariant s_tap.tap_enclave_metadata_regs[eid] == f_tap.tap_enclave_metadata_regs[c_eid];
        invariant s_tap.tap_enclave_metadata_paused[eid] == f_tap.tap_enclave_metadata_paused[c_eid];
        invariant s_tap.tap_enclave_metadata_cache_conflict[eid] == f_tap.tap_enclave_metadata_cache_conflict[c_eid];
        invariant s_tap.tap_enclave_metadata_region_bounds[eid] == f_tap.tap_enclave_metadata_region_bounds[c_eid];
        invariant s_tap.tap_enclave_metadata_bounds_valid[eid] == f_tap.tap_enclave_metadata_bounds_valid[c_eid];

        // Extra stuff
        invariant (current_mode == mode_enclave ==> tap_addr_perm_x(s_tap.cpu.cpu_addr_valid[s_tap.cpu.cpu_pc]));
        invariant (current_mode == mode_enclave ==> s_tap.tap_enclave_metadata_addr_excl[eid][s_tap.cpu.cpu_pc]);
        invariant (current_mode == mode_enclave ==> s_tap.cpu.cpu_owner_map[s_tap.cpu.cpu_addr_map[s_tap.cpu.cpu_pc]] == eid);
        invariant (current_mode == mode_enclave ==> tap_addr_perm_x(f_tap.cpu.cpu_addr_valid[f_tap.cpu.cpu_pc]));
        invariant (current_mode == mode_enclave ==> f_tap.tap_enclave_metadata_addr_excl[eid][f_tap.cpu.cpu_pc]);
        invariant (current_mode == mode_enclave ==> f_tap.cpu.cpu_owner_map[f_tap.cpu.cpu_addr_map[f_tap.cpu.cpu_pc]] == eid);

        // eid is valid.
        invariant valid_enclave_id(eid); 
        invariant !enclave_dead ==>
                    (s_tap.tap_enclave_metadata_valid[eid] && f_tap.tap_enclave_metadata_valid[eid]);
        // cpu.cpu_enclave_id is never blocked_enclave_id
        invariant (s_tap.cpu.cpu_enclave_id != tap_blocked_enc_id);
        invariant (f_tap.cpu.cpu_enclave_id != tap_blocked_enc_id);
        // the entrypoint always has an executable vaddr -> paddr mapping.
        invariant !enclave_dead ==>
                    tap_addr_perm_x(s_tap.tap_enclave_metadata_addr_valid[eid][s_tap.tap_enclave_metadata_entrypoint[eid]]);
        invariant !enclave_dead ==>
                    tap_addr_perm_x(f_tap.tap_enclave_metadata_addr_valid[eid][f_tap.tap_enclave_metadata_entrypoint[eid]]);
        invariant !enclave_dead ==>
                    s_tap.tap_enclave_metadata_addr_excl[eid][s_tap.tap_enclave_metadata_entrypoint[eid]];
        invariant !enclave_dead ==>
                    f_tap.tap_enclave_metadata_addr_excl[eid][f_tap.tap_enclave_metadata_entrypoint[eid]];
        // the pc always has an executable vaddr -> paddr mapping. 
        invariant !enclave_dead ==>
                    tap_addr_perm_x(s_tap.tap_enclave_metadata_addr_valid[eid][s_tap.tap_enclave_metadata_pc[eid]]);
        invariant !enclave_dead ==>
                    tap_addr_perm_x(f_tap.tap_enclave_metadata_addr_valid[eid][f_tap.tap_enclave_metadata_pc[eid]]);
        invariant !enclave_dead ==>
                    s_tap.tap_enclave_metadata_addr_excl[eid][s_tap.tap_enclave_metadata_pc[eid]];
        invariant !enclave_dead ==>
                    f_tap.tap_enclave_metadata_addr_excl[eid][f_tap.tap_enclave_metadata_pc[eid]];
        // the cpu.cpu_owner_map and enclave's excl_map are consistent.
        invariant (forall (pa: wap_addr_t) :: 
                    !enclave_dead ==> (s_tap.cpu.cpu_owner_map[pa] == eid <==> e_excl_map[pa]));
        invariant (forall (pa: wap_addr_t) :: 
                    !enclave_dead ==> (f_tap.cpu.cpu_owner_map[pa] == eid <==> e_excl_map[pa]));
        invariant (!enclave_dead) ==>
                     (s_tap.tap_enclave_metadata_addr_excl[eid] == e_excl_vaddr);
        invariant (!enclave_dead) ==>
                     (f_tap.tap_enclave_metadata_addr_excl[eid] == e_excl_vaddr);
        invariant (!enclave_dead) ==>
                     (s_tap.tap_enclave_metadata_bounds_valid[eid] == f_tap.tap_enclave_metadata_bounds_valid[eid]);
        invariant (!enclave_dead) ==>
                     (s_tap.tap_enclave_metadata_region_bounds[eid] == f_tap.tap_enclave_metadata_region_bounds[eid]);

         // invariants about the states of the CPUs.
        // are we in attacker mode?
        invariant (current_mode == mode_untrusted) ==> (s_tap.cpu.cpu_enclave_id != eid);
        invariant (current_mode == mode_untrusted) ==> (f_tap.cpu.cpu_enclave_id == tap_null_enc_id);
        // if we are in trusted mode, we mean our enclave. 
        invariant (current_mode == mode_enclave ==> 
                    (s_tap.cpu.cpu_enclave_id == eid  && f_tap.cpu.cpu_enclave_id == eid));
        invariant current_mode == mode_enclave ==> s_tap.cpu.cpu_enclave_id == eid;
        invariant current_mode == mode_enclave ==> f_tap.cpu.cpu_enclave_id == eid;
        // the CPU state is also the same in trusted mode.
        invariant (current_mode == mode_enclave ==> s_tap.cpu.cpu_pc == f_tap.cpu.cpu_pc);
        invariant (current_mode == mode_enclave ==> tap_addr_perm_x(s_tap.cpu.cpu_addr_valid[s_tap.cpu.cpu_pc]));
        invariant (current_mode == mode_enclave ==> tap_addr_perm_x(f_tap.cpu.cpu_addr_valid[f_tap.cpu.cpu_pc]));
        invariant (current_mode == mode_enclave ==> s_tap.tap_enclave_metadata_addr_excl[eid][s_tap.cpu.cpu_pc]);
        invariant (current_mode == mode_enclave ==> f_tap.tap_enclave_metadata_addr_excl[eid][f_tap.cpu.cpu_pc]);
        invariant (current_mode == mode_enclave ==> s_tap.cpu.cpu_owner_map[s_tap.cpu.cpu_addr_map[s_tap.cpu.cpu_pc]] == eid);
        invariant (current_mode == mode_enclave ==> f_tap.cpu.cpu_owner_map[f_tap.cpu.cpu_addr_map[f_tap.cpu.cpu_pc]] == eid);
        // if we are in trusted mode, then metadata and CPU state are the same.
        invariant (forall (ri : regindex_t) ::
                    (current_mode == mode_enclave) ==>
                        (s_tap.cpu.cpu_regs[ri] == f_tap.cpu.cpu_regs[ri]));
        // This states that the two traces update addr_valid in the same way.
        invariant (forall (va : vaddr_t) ::
                    (current_mode == mode_enclave && e_excl_vaddr[va]) ==>
                        (s_tap.cpu.cpu_addr_valid[va] == f_tap.cpu.cpu_addr_valid[va]));
        // But note cpu.cpu_addr_valid may differ from the tap_enclave_metadata_addr_valid because 
        // the accessed bit is set in the form.
        //invariant (forall (va : vaddr_t) ::
        //            (current_mode == mode_enclave) ==>
        //                tap_addr_perm_eq(s_tap.tap_enclave_metadata_addr_valid[eid][va], s_tap.cpu.cpu_addr_valid[va]));
        invariant (forall (va : vaddr_t) ::
                    (current_mode == mode_enclave) ==>
                        tap_addr_perm_eq(f_tap.tap_enclave_metadata_addr_valid[eid][va], f_tap.cpu.cpu_addr_valid[va]));
        invariant (forall (va : vaddr_t) ::
                    (current_mode == mode_enclave && e_excl_vaddr[va]) ==>
                        (e_addr_map[va] == s_tap.cpu.cpu_addr_map[va]));
        invariant (forall (va : vaddr_t) ::
                    (current_mode == mode_enclave && e_excl_vaddr[va]) ==>
                        (e_addr_map[va] == f_tap.cpu.cpu_addr_map[va]));

    {
        havoc r_eid; havoc r_proof_op; havoc e_proof_op; havoc r_regs; havoc r_parent_eid;
        if (current_mode == mode_untrusted) {
            var old_cpu_enclave_id_1 : tap_enclave_id_t;
            old_cpu_enclave_id_1 = s_tap.cpu.cpu_enclave_id;

            assume (r_eid != eid || r_proof_op != tap_proof_op_destroy);

            // execute the operation in trace_1
            call (current_mode, enclave_dead) = s_tap.IntegrityAdversarialStep(
                    mode_untrusted, eid, r_eid, r_parent_eid, r_regs, r_proof_op);


            // if the mode changed, we need to do this in trace_2
            if (current_mode == mode_enclave) {
                assert (r_proof_op == tap_proof_op_enter || r_proof_op == tap_proof_op_resume);
                assert (r_eid == eid);
                call (current_mode, enclave_dead) = f_tap.IntegrityAdversarialStep(
                        mode_enclave, c_eid, c_eid, r_parent_eid, r_regs, r_proof_op);
                // sanity check.
                assert current_mode == mode_enclave;
                assert (s_tap.cpu.cpu_enclave_id == eid && f_tap.cpu.cpu_enclave_id == c_eid); // Sanity check
                assert !enclave_dead;
                //assert(false);
            } 
            //assert(false);
        } else {
            if (current_mode == mode_enclave) {
                assert (s_tap.cpu.cpu_enclave_id == eid && f_tap.cpu.cpu_enclave_id == c_eid); // Sanity check
                havoc iter;

                assume standard_tap_proof_op_valid_in_enclave(e_proof_op);
                assume e_proof_op != tap_proof_op_snapshot; // No snapshot yet
                

                // enclave step in trace_1
                call (current_mode_1, vaddr_1, paddr_1, data_1) = s_tap.IntegrityEnclaveStep(
                                                                e_proof_op, iter);

                // enclave step in trace_2
                call (current_mode_2, vaddr_2, paddr_2, data_2) = f_tap.IntegrityEnclaveStep(
                                                                e_proof_op, iter);
                assert(current_mode_1 == current_mode_2);
                current_mode = current_mode_1;
                assert vaddr_1 == vaddr_2;
                assert data_1 == data_2;
                assert(false);
            }
            //assert(false);
        }
        //assert(false);


    }



    
    
}


control {
  set_solver_option(":mbqi", false);
  set_solver_option(":case_split", 0);
  set_solver_option(":relevancy", 0);
  set_solver_option(":threads", 4);
  set_solver_option(":blast_full", true);
  set_solver_option(":timeout", 120000);
  verif_prove_integrity = verify(ProveSemanticEquivalence);
  check;
  print_results;


  //print_module;

}

}
