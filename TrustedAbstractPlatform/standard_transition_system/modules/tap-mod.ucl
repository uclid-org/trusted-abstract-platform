module tap { 
  //=======================================================//
  // Prelude                                               //
  //=======================================================//

  // Import types, constants, functions, and define macros
  // from ap_types module.
  type * = ap_types.*;
  const * = ap_types.*;
  function * = ap_types.*;
  define * = ap_types.*;

  //=======================================================//
  // Data Cache Model                                      //
  //=======================================================//

  /* Cache state variables

     @cache_valid_map map that stores the valid bit for each cache line
     @cache_tag_map   map that stores the tag for each cache line
  */
  var cache_valid_map  : cache_valid_map_t;
  var cache_tag_map    : cache_tag_map_t;

  procedure [noinline] init_cache()
    ensures (forall (i : cache_set_index_t, w : cache_way_index_t) ::
        (valid_cache_set_index(i) && valid_cache_way_index(w)) ==> !cache_valid_map[i, w]);
    modifies cache_valid_map;
  {
    var ind : cache_set_index_t;
    var way : cache_way_index_t;
    ind = 0;

    while (ind < kmax_cache_set_index_t)
      invariant (forall (i : cache_set_index_t, w : cache_way_index_t) ::
          (i >= 0 && i < ind && valid_cache_way_index(w)) ==> !cache_valid_map[i, w]);
    {
      way = 0;
      while (way < kmax_cache_way_index_t)
        invariant (forall (i : cache_set_index_t, w : cache_way_index_t) ::
            ((i >= 0 && i < ind && valid_cache_way_index(w)) || (i == ind && w >= 0 && w < way)) ==>
            !cache_valid_map[i, w]);
      {
        cache_valid_map[ind, way] = false;
        way = way + 1;
      }
      ind = ind + 1;
    }
  }

  procedure [noinline] query_cache(pa : wap_addr_t, repl_way : cache_way_index_t)
    returns (hit : boolean, hit_way : cache_way_index_t)
    requires (valid_cache_way_index(repl_way));
    
    // set hit status
    ensures !hit <==> (forall (w : cache_way_index_t) ::
                        valid_cache_way_index(w) ==>
                          (!old(cache_valid_map)[paddr2set(pa) , w] ||
                            old(cache_tag_map)[paddr2set(pa), w] != paddr2tag(pa)));
    ensures (hit <==> (exists (w : cache_way_index_t) ::
                        valid_cache_way_index(w)              &&
                        old(cache_valid_map)[paddr2set(pa), w] &&
                        old(cache_tag_map)[paddr2set(pa), w] == paddr2tag(pa)));
    // do replacement if necessary.
    ensures (if (!hit)
                then cache_valid_map[paddr2set(pa), repl_way]
                else cache_valid_map[paddr2set(pa), hit_way]);
    ensures (if (!hit)
                then cache_tag_map[paddr2set(pa), repl_way] == paddr2tag(pa)
                else cache_tag_map[paddr2set(pa), hit_way]  == paddr2tag(pa));

    // and no other lines are affected.
    ensures !hit ==>
            (forall (i : cache_set_index_t, w : cache_way_index_t) ::
              (i != paddr2set(pa) || w != repl_way) ==> cache_valid_map[i, w] == old(cache_valid_map)[i, w]);
    ensures !hit ==>
            (forall (i : cache_set_index_t, w : cache_way_index_t) ::
              (i != paddr2set(pa) || w != repl_way) ==> cache_tag_map[i, w] == old(cache_tag_map)[i, w]);
    ensures hit ==> (cache_valid_map == old(cache_valid_map) && cache_tag_map == old(cache_tag_map));
    modifies cache_valid_map, cache_tag_map;
  {
    var set : cache_set_index_t;
    var tag : cache_tag_t;
    var way : cache_way_index_t;

    set = paddr2set(pa);
    tag = paddr2tag(pa);

    way = 0;
    hit = false;
    while(!hit && way < kmax_cache_way_index_t)
      invariant (way >= 0);
      invariant (way <= kmax_cache_way_index_t);
      invariant hit ==> (cache_valid_map[set, hit_way] && cache_tag_map[set, hit_way] == tag);
      invariant
        (!hit <==>
          (forall (w : cache_way_index_t) ::
            (w >= 0 && w < way) ==>
              (!cache_valid_map[set, w] || cache_tag_map[set, w] != tag)));
    {
      if (cache_valid_map[set, way] && cache_tag_map[set, way] == tag) {
        hit = true;
        hit_way = way;
      }
      way = way + 1;
    }

    if (!hit) {
      cache_valid_map[set, repl_way] = true;
      cache_tag_map[set, repl_way] = tag;
    }
  }

  procedure update_cache(pa : wap_addr_t)
    modifies cache_valid_map;
    modifies cache_tag_map;
  {
    havoc cache_valid_map;
    havoc cache_tag_map;
  }

  procedure set_cache_state(_cache_valid_map : cache_valid_map_t, _cache_tag_map : cache_tag_map_t)
    ensures (cache_valid_map == _cache_valid_map);
    ensures (cache_tag_map == _cache_tag_map);
    modifies cache_valid_map;
    modifies cache_tag_map;
  {
    cache_valid_map = _cache_valid_map;
    cache_tag_map = _cache_tag_map;
  }

  //=======================================================//
  // CPU Model                                             //
  //=======================================================//

  //
  // CPU state
  //
  var cpu_mem         : mem_t;
  var cpu_regs        : regs_t;
  var cpu_pc          : vaddr_t;
  var cpu_enclave_id  : tap_enclave_id_t;
  var cpu_addr_valid  : addr_valid_t;
  var cpu_addr_map    : addr_map_t;
  var cpu_owner_map   : owner_map_t;

  //
  // CPU Flags
  //
  var cpu_cache_enabled : boolean;

  //
  // CPU Procedures 
  //
  procedure initialize_cache() 
    modifies cache_valid_map;
  {
    call init_cache();
  }

  procedure [inline] set_cache(_valid_map: cache_valid_map_t, _tag_map : cache_tag_map_t)
    modifies cache_valid_map;
    modifies cache_tag_map;
  {
    call set_cache_state(_valid_map, _tag_map);
  }

  procedure [inline] set_cpu_state(
    _cpu_enclave_id : tap_enclave_id_t,
    _cpu_addr_map   : addr_map_t,
    _cpu_addr_valid : addr_valid_t,
    _cpu_pc         : vaddr_t,
    _cpu_regs       : regs_t
  )
    modifies cpu_enclave_id;
    modifies cpu_addr_map;
    modifies cpu_addr_valid;
    modifies cpu_pc;
    modifies cpu_regs;
  {
    cpu_enclave_id = _cpu_enclave_id;
    cpu_addr_map   = _cpu_addr_map;
    cpu_addr_valid = _cpu_addr_valid;
    cpu_pc         = _cpu_pc;
    cpu_regs       = _cpu_regs;
  }


  procedure [inline] update_cpu_owner_map(paddr : wap_addr_t, eid : tap_enclave_id_t)
    modifies cpu_owner_map;
  {
    cpu_owner_map[paddr] = eid;
  }

  procedure [inline] update_cpu_mem(paddr : wap_addr_t, word : word_t)
    modifies cpu_mem;
  {
    cpu_mem[paddr] = word;
  }

  procedure [inline] update_cpu_addr_valid(vaddr : vaddr_t, valid : addr_perm_t)
    modifies cpu_addr_valid;
  {
    cpu_addr_valid[vaddr] = valid;
  }

  procedure [inline] update_cpu_addr_map(vaddr : vaddr_t, paddr : wap_addr_t)
    modifies cpu_addr_map;
  {
    cpu_addr_map[vaddr] = paddr;
  }

  procedure [inline] update_cpu_regs(idx : regindex_t, word : word_t)
    modifies cpu_regs;
  {
    cpu_regs[idx] = word;
  }



  procedure [inline] set_cpu_owner_map(_cpu_owner_map : owner_map_t)
    modifies cpu_owner_map;
  {
    cpu_owner_map = _cpu_owner_map;
  }

  procedure [inline] set_cpu_mem(_cpu_mem : mem_t)
    modifies cpu_mem;
  {
    cpu_mem = _cpu_mem;
  }

  procedure [inline] set_cpu_addr_valid(_cpu_addr_valid : addr_valid_t)
    modifies cpu_addr_valid;
  {
    cpu_addr_valid = _cpu_addr_valid;
  }

  procedure [inline] set_cpu_addr_map(_cpu_addr_map : addr_map_t)
    modifies cpu_addr_map;
  {
    cpu_addr_map = _cpu_addr_map;
  }


  procedure [inline] set_cpu_pc(_cpu_pc : vaddr_t)
    modifies cpu_pc;
  {
    cpu_pc = _cpu_pc;
  }

  procedure [inline] set_cpu_regs(_cpu_regs : regs_t)
    modifies cpu_regs;
  {
    cpu_regs = _cpu_regs;
  }


  procedure [inline] havoc_cpu_mem()
    modifies cpu_mem;
  {
    havoc cpu_mem;
  }

  procedure [inline] havoc_cpu_owner_map()
    modifies cpu_owner_map;
  {
    havoc cpu_owner_map;
  }

  procedure [inline] havoc_cpu_pc()
    modifies cpu_pc;
  {
    havoc cpu_pc;
  }

  procedure [inline] havoc_cpu_regs()
    modifies cpu_regs;
  {
    havoc cpu_regs;
  }

  procedure [inline] fetch_va(vaddr : vaddr_t, repl_way : cache_way_index_t)
    returns (data : word_t, excp : exception_t, hit : boolean)
    requires valid_cache_way_index(repl_way);
    modifies cpu_addr_valid;
    modifies cache_valid_map, cache_tag_map;
  {
    var paddr : wap_addr_t;
    var owner_eid : tap_enclave_id_t;
    var hit_way : cache_way_index_t;
    
    // default
    data = k0_word_t;
    hit = false;


    
    // translate VA -> PA
    if (!tap_addr_perm_x(cpu_addr_valid[vaddr])) {
      excp = excp_os_protection_fault; 
    } else {
      paddr = cpu_addr_map[vaddr];
      // are we not allowed to access this memory
      owner_eid = cpu_owner_map[paddr];
      if (owner_eid != tap_null_enc_id && owner_eid != cpu_enclave_id) {
        excp = excp_os_protection_fault; 
      } else {
        // update accessed bit
        cpu_addr_valid[vaddr] = tap_set_addr_perm_a(cpu_addr_valid[vaddr]);
        // perform load
        data = cpu_mem[paddr];
        excp = excp_none;
        // update cahce
        if (cpu_cache_enabled) {
          assert(valid_cache_way_index(repl_way));
          call (hit, hit_way) = query_cache(paddr, repl_way);
        }
      }
    }
  }

  procedure [inline] load_va(vaddr : vaddr_t, repl_way : cache_way_index_t)
    returns (data : word_t, excp : exception_t, hit : boolean)
    requires valid_cache_way_index(repl_way);
    ensures (!tap_addr_perm_r(old(cpu_addr_valid)[vaddr]) ||
             (cpu_owner_map[cpu_addr_map[vaddr]] != tap_null_enc_id && cpu_owner_map[cpu_addr_map[vaddr]] != cpu_enclave_id))
              ==> (hit == false);
    ensures (forall (p : wap_addr_t, w : cache_way_index_t) ::
              (paddr2set(p) != paddr2set(cpu_addr_map[vaddr]) || w != repl_way)
                ==> ((cache_valid_map[paddr2set(p), w] == old(cache_valid_map)[paddr2set(p), w]) &&
                     (cache_tag_map[paddr2set(p), w] == old(cache_tag_map)[paddr2set(p), w])));

    ensures (excp == excp_none && cpu_cache_enabled && !hit)
                ==> ((cache_valid_map[paddr2set(old(cpu_addr_map)[vaddr]), repl_way] == true) &&
                      (cache_tag_map[paddr2set(old(cpu_addr_map)[vaddr]), repl_way] == paddr2tag(old(cpu_addr_map)[vaddr])));
    ensures (!cpu_cache_enabled) ==> (cache_valid_map == old(cache_valid_map) && cache_tag_map == old(cache_tag_map));


    modifies cpu_addr_valid;
    modifies cache_valid_map, cache_tag_map;
  {
    var paddr : wap_addr_t;
    var owner_eid : tap_enclave_id_t;
    var hit_way : cache_way_index_t;
    
    // default 
    data = k0_word_t;
    hit = false;

    // translate VA -> PA
    if (!tap_addr_perm_r(cpu_addr_valid[vaddr])) {
      excp = excp_os_protection_fault; 
    } else {
      paddr = cpu_addr_map[vaddr];
      // are we not allowed to access this memory
      owner_eid = cpu_owner_map[paddr];
      if (owner_eid != tap_null_enc_id && owner_eid != cpu_enclave_id) {
        excp = excp_tp_protection_fault; 
      } else {
        // update accessed bit
        cpu_addr_valid[vaddr] = tap_set_addr_perm_a(cpu_addr_valid[vaddr]);
        // perform load
        data = cpu_mem[paddr];
        excp = excp_none;
        // update cache
        if (cpu_cache_enabled) {
          call (hit, hit_way) = query_cache(paddr, repl_way);
        }
      }
    }
  }

  procedure [inline] store_va(vaddr : vaddr_t, data : word_t, repl_way : cache_way_index_t)
    returns (excp : exception_t, hit : boolean)
    requires valid_cache_way_index(repl_way);
    ensures (excp != excp_none ==> cpu_mem == old(cpu_mem));
    ensures (excp != excp_none) ==> (cpu_addr_valid == old(cpu_addr_valid));
    ensures (excp == excp_none) ==> 
              (forall (va : vaddr_t) ::
                (va != vaddr)
                  ==> (cpu_addr_valid[va] == old(cpu_addr_valid)[va]));
    ensures (excp == excp_none) 
              ==> (cpu_addr_valid[vaddr] == tap_set_addr_perm_a(old(cpu_addr_valid)[vaddr]));
    ensures (!tap_addr_perm_w(old(cpu_addr_valid)[vaddr]) ||
             (cpu_owner_map[cpu_addr_map[vaddr]] != tap_null_enc_id && cpu_owner_map[cpu_addr_map[vaddr]] != cpu_enclave_id))
            ==> (hit == false);
    ensures (forall (p : wap_addr_t, w : cache_way_index_t) ::
              (paddr2set(p) != paddr2set(cpu_addr_map[vaddr]) || w != repl_way)
                ==> ((cache_valid_map[paddr2set(p), w] == old(cache_valid_map)[paddr2set(p), w]) &&
                     (cache_tag_map[paddr2set(p), w] == old(cache_tag_map)[paddr2set(p), w])));
    

    ensures (!cpu_cache_enabled) ==> (cache_valid_map == old(cache_valid_map) && cache_tag_map == old(cache_tag_map));

    
    modifies cpu_mem;
    modifies cpu_addr_valid;
    modifies cache_valid_map, cache_tag_map;
  {
    var paddr : wap_addr_t;
    var owner_eid : tap_enclave_id_t;
    var hit_way : cache_way_index_t;
    
    // default
    hit = false;

    //translate VA -> PA
    if (!tap_addr_perm_w(cpu_addr_valid[vaddr])) {
      excp = excp_os_protection_fault; ;
    } else {
      paddr = cpu_addr_map[vaddr];
      // are we not allowed to access this memory
      owner_eid = cpu_owner_map[paddr];
      if (owner_eid != tap_null_enc_id && owner_eid != cpu_enclave_id) {
        excp = excp_tp_protection_fault; 
      } else {
        // update accessed bit
        cpu_addr_valid[vaddr] = tap_set_addr_perm_a(cpu_addr_valid[vaddr]);
        // perform store
        cpu_mem[paddr] = data;
        excp = excp_none;
        // update cache
        if (cpu_cache_enabled) {
          call (hit, hit_way) = query_cache(paddr, repl_way);
        }
      }
    }
    assert (forall (v : vaddr_t) ::
              (v != vaddr) ==> (cpu_addr_valid[v] == old(cpu_addr_valid)[v])); 
  }


  procedure modify_owner_map(eid : tap_enclave_id_t, excl_paddr : excl_map_t)
    returns (status : enclave_op_result_t)
    modifies cpu_owner_map;
    modifies cpu_mem;
  {
    havoc cpu_owner_map;
    havoc cpu_mem;
  }

  // Inputs to the adversary or enclave
  input tap_r_eid: tap_enclave_id_t;
  input tap_eid: tap_enclave_id_t;
  input tap_r_proof_op: tap_proof_op_t;
  input tap_e_proof_op: tap_proof_op_t;
  input tap_r_regs: regs_t;
  input tap_iter: integer;

  // State variables
  output tap_current_mode: mode_t;
  output tap_enclave_dead: boolean;
  var tap_vaddr: vaddr_t;
  var tap_paddr: wap_addr_t;
  var tap_data: word_t;

  //
  // TAP uarch state
  //
  const block_os_ev_read  : boolean;

  //
  // State of the untrusted code (OS and its minion).
  //
  //the untrusted pages
  var untrusted_addr_valid : addr_valid_t;
  var untrusted_addr_map   : addr_map_t;
  var untrusted_regs       : regs_t;
  var untrusted_pc         : vaddr_t;

  //
  // The enclaves in the system
  //
  var tap_enclave_metadata_valid          : tap_enclave_metadata_valid_t;
  var tap_enclave_metadata_addr_map       : tap_enclave_metadata_addr_map_t;
  var tap_enclave_metadata_addr_valid     : tap_enclave_metadata_addr_valid_t;
  var tap_enclave_metadata_addr_excl      : tap_enclave_metadata_addr_excl_t;
  var tap_enclave_metadata_num_threads    : tap_enclave_metadata_num_threads_t;
  var tap_enclave_metadata_entrypoint     : tap_enclave_metadata_entrypoint_t;
  var tap_enclave_metadata_pc             : tap_enclave_metadata_pc_t;
  var tap_enclave_metadata_regs           : tap_enclave_metadata_regs_t;
  var tap_enclave_metadata_paused         : tap_enclave_metadata_paused_t;
  var tap_enclave_metadata_cache_conflict : tap_enclave_metadata_cache_conflict_t;

  //
  // Helper Procedures
  //
  procedure [noinline] do_mappings_alias_v(
    addr_valid : excl_vaddr_t,
    addr_map   : addr_map_t
  )
    returns (alias : boolean)
    ensures (exists (v1, v2 : vaddr_t) :: vaddr_alias(addr_valid, addr_map, v1, v2))
            <==> alias;
    ensures (forall (v1, v2 : vaddr_t) :: !vaddr_alias(addr_valid, addr_map, v1, v2))
            <==> (!alias);
  {
  }

  procedure does_paddr_conflict(eid : tap_enclave_id_t, pa1 : wap_addr_t)
    returns (conflict : boolean)
    requires cpu_owner_map[pa1] == eid;
    ensures (exists (p : wap_addr_t) ::
                  cpu_owner_map[p] != eid && paddr2set(pa1) == paddr2set(p))
            <==> conflict;
  {
    var pa : wap_addr_t;

    pa = k0_wap_addr_t;
    conflict = false;
    while (LT_wapa(pa, kmax_wap_addr_t))
      invariant (exists (p : wap_addr_t) ::
                  LT_wapa(p, pa) && cpu_owner_map[p] != eid && paddr2set(pa1) == paddr2set(p))
                <==> conflict;
    {
      if (cpu_owner_map[pa] != eid && paddr2set(pa1) == paddr2set(pa)) {
        conflict = true;
      }
      pa = PLUS_wapa(pa, k1_wap_addr_t);
    }
    if (cpu_owner_map[pa] != eid && paddr2set(pa1) == paddr2set(pa)) {
      conflict = true;
    }
  }

  procedure does_enclave_conflict(eid : tap_enclave_id_t)
    returns (conflict : boolean)
    ensures (exists (p1, p2 : wap_addr_t) ::
                  cpu_owner_map[p1] == eid  &&
                  cpu_owner_map[p2] != eid  &&
                  paddr2set(p1) == paddr2set(p2))
              <==> conflict;
  {
    var pa : wap_addr_t;
    var pa_conflict : boolean;

    pa = k0_wap_addr_t;
    conflict = false;
    while (LT_wapa(pa, kmax_wap_addr_t))
      invariant (exists (p1, p2 : wap_addr_t) ::
                    LT_wapa(p1, pa)           &&
                    cpu_owner_map[p1] == eid  &&
                    cpu_owner_map[p2] != eid  &&
                    paddr2set(p1) == paddr2set(p2))
                <==> conflict;
    {
      if (cpu_owner_map[pa] == eid) {
        call (pa_conflict) = does_paddr_conflict(eid, pa);
        conflict = conflict || pa_conflict;
      }
      pa = PLUS_wapa(pa, k1_wap_addr_t);
    }
    if (cpu_owner_map[pa] == eid) {
      call (pa_conflict) = does_paddr_conflict(eid, pa);
      conflict = conflict || pa_conflict;
    }
  }

  //
  // CPU Procedures
  //
  procedure [noinline] initialize_tap()
    ensures cpu_enclave_id == tap_null_enc_id;
    ensures cpu_addr_map == untrusted_addr_map;
    ensures cpu_addr_valid == untrusted_addr_valid;
    ensures cpu_pc == untrusted_pc;
    ensures cpu_regs == untrusted_regs;
    ensures (forall (p : wap_addr_t) :: cpu_mem[p] == k0_word_t);
    ensures (forall (p : wap_addr_t) :: cpu_owner_map[p] == tap_null_enc_id);
    ensures (forall (e : tap_enclave_id_t) :: !tap_enclave_metadata_valid[e]);
    ensures (tap_addr_perm_x(cpu_addr_valid[cpu_pc]));
    ensures cpu_cache_enabled ==>
              (forall (i : cache_set_index_t, w : cache_way_index_t) ::
                (valid_cache_set_index(i) && valid_cache_way_index(w)) ==> !cache_valid_map[i, w]);
    ensures (forall (pa : wap_addr_t, e : tap_enclave_id_t) :: 
              (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==>
                (cpu_owner_map[pa] != e));
    ensures (forall (e : tap_enclave_id_t) ::
              tap_enclave_metadata_valid[e] ==>
                tap_addr_perm_x((tap_enclave_metadata_addr_valid[e])[tap_enclave_metadata_entrypoint[e]]));
    modifies untrusted_addr_map,
             untrusted_addr_valid,
             untrusted_pc,
             untrusted_regs,
             tap_enclave_metadata_valid;
    modifies cpu_enclave_id;
    modifies cpu_addr_map;
    modifies cpu_addr_valid;
    modifies cpu_pc;
    modifies cpu_regs;
    modifies cpu_mem;
    modifies cpu_owner_map;
    modifies cache_valid_map;
  {
    havoc untrusted_addr_map;
    havoc untrusted_addr_valid;
    havoc untrusted_addr_map; 
    havoc untrusted_pc;
    havoc untrusted_regs;
    
      
    call set_cpu_state(tap_null_enc_id,
                       untrusted_addr_map,
                       untrusted_addr_valid,
                       untrusted_pc,
                       untrusted_regs);
    


    // memory is all zero'd out
    call havoc_cpu_mem();
    assume (forall (p : wap_addr_t) :: cpu_mem[p] == k0_word_t);
    
    
    // no enclaves exists
    call havoc_cpu_owner_map();
    assume (forall (pa : wap_addr_t) :: cpu_owner_map[pa] == tap_null_enc_id);
    havoc tap_enclave_metadata_valid;
    assume (forall (e : tap_enclave_id_t) :: !tap_enclave_metadata_valid[e]);
    // and that the PC is in the same state
    assume (tap_addr_perm_x(cpu_addr_valid[cpu_pc]));
    assume (cpu_owner_map[cpu_addr_map[cpu_pc]] == cpu_enclave_id);
    
    if (cpu_cache_enabled) {
      call initialize_cache();
    }


  }

  procedure [inline] set_addr_map(va : vaddr_t, pa : wap_addr_t, valid : addr_perm_t)
    //ensures (cpu_enclave_id == tap_null_enc_id ==> (untrusted_addr_valid[va] == valid &&
    //            cpu_addr_valid == untrusted_addr_valid));
    //ensures ((cpu_enclave_id == tap_null_enc_id && tap_addr_perm_v(valid)) ==>
    //            (untrusted_addr_map[va] == pa && cpu_addr_map == untrusted_addr_map));
    //ensures (cpu_enclave_id != tap_null_enc_id ==>
    //        cpu_addr_valid == old(cpu_addr_valid));

    modifies untrusted_addr_valid,
             untrusted_addr_map;
    modifies cpu_addr_valid,
             cpu_addr_map;

  {
    if (cpu_enclave_id == tap_null_enc_id) {
      untrusted_addr_valid[va] = valid;
      call set_cpu_addr_valid(untrusted_addr_valid);
      if (tap_addr_perm_v(valid)) {
        untrusted_addr_map[va] = pa;
        call set_cpu_addr_map(untrusted_addr_map);
      }
    }
              
  }

  procedure [inline] get_enclave_addr_map(eid : tap_enclave_id_t, va  : vaddr_t)
      returns (valid : addr_perm_t, paddr: wap_addr_t)
      ensures (block_os_ev_read && (tap_enclave_metadata_addr_excl[eid])[va])
              ==> (valid == k0_addr_perm_t && paddr == k0_wap_addr_t);
      ensures (cpu_enclave_id != tap_null_enc_id || !tap_enclave_metadata_valid[eid])
              ==> (valid == k0_addr_perm_t && paddr == k0_wap_addr_t);
      ensures (cpu_enclave_id == tap_null_enc_id && tap_enclave_metadata_valid[eid] && (!block_os_ev_read || !((tap_enclave_metadata_addr_excl[eid])[va])))
              ==> (valid == (tap_enclave_metadata_addr_valid[eid])[va] &&
                   paddr == (tap_enclave_metadata_addr_map[eid])[va]);
  {
    // default values
    valid = k0_addr_perm_t;
    paddr = k0_wap_addr_t;
    if (cpu_enclave_id == tap_null_enc_id   &&
        tap_enclave_metadata_valid[eid])
    {
      if (!block_os_ev_read || !((tap_enclave_metadata_addr_excl[eid])[va])) {
        valid = (tap_enclave_metadata_addr_valid[eid])[va];
        paddr = (tap_enclave_metadata_addr_map[eid])[va];
      }
    }
  }

  procedure [inline] set_enclave_addr_map(
    eid    : tap_enclave_id_t,
    va     : vaddr_t,
    valid  : addr_perm_t,
    paddr  : wap_addr_t
  )
    returns (status : enclave_op_result_t)
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_map;
  {
    // default values
    if (cpu_enclave_id == tap_null_enc_id &&
        tap_enclave_metadata_valid[eid])
    {
      if (!(tap_enclave_metadata_addr_excl[eid])[va]) {
        var valid_map : addr_valid_t;
        var addr_map  : addr_map_t;
        valid_map = tap_enclave_metadata_addr_valid[eid];
        addr_map  = tap_enclave_metadata_addr_map[eid];
        valid_map[va] = valid;
        addr_map[va]  = paddr;
        tap_enclave_metadata_addr_valid[eid] = valid_map;
        tap_enclave_metadata_addr_map[eid] = addr_map;
        status = enclave_op_success;
      } else {
        status = enclave_op_invalid_arg;
      } 
    } else {
      status = enclave_op_invalid_arg;
    }
  }

  //
  // Helper definitions
  //
  define vaddr_alias(
    av       : excl_vaddr_t,
    am       : addr_map_t,
    va1, va2 : vaddr_t) : boolean
  = (va1 != va2 && av[va1] && av[va2] && am[va1] == am[va2]);
    
  //
  // Launch and enclave
  //
  procedure [noinline] launch(
    eid               : tap_enclave_id_t,
    addr_valid        : addr_valid_t,
    addr_map          : addr_map_t,
    excl_vaddr        : excl_vaddr_t,
    excl_paddr        : excl_map_t,
    entrypoint        : vaddr_t
  )
    returns (status : enclave_op_result_t)
    //
    // global TAP invariants
    //
    requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==>
                    (cpu_owner_map[pa] != e));

      
    ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==>
                    (cpu_owner_map[pa] != e));


    
     //these postconditions say that nothing change if status != success
    
    ensures (status != enclave_op_success ==> cpu_owner_map == old(cpu_owner_map));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_valid == old(tap_enclave_metadata_valid));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_map == old(tap_enclave_metadata_addr_map));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_valid == old(tap_enclave_metadata_addr_valid));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_excl == old(tap_enclave_metadata_addr_excl));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_entrypoint == old(tap_enclave_metadata_entrypoint));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_pc == old(tap_enclave_metadata_pc));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_regs == old(tap_enclave_metadata_regs));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_paused == old(tap_enclave_metadata_paused));
    ensures (status != enclave_op_success ==> tap_enclave_metadata_cache_conflict == old(tap_enclave_metadata_cache_conflict));

    
     //these postconditions say that only entry [eid] changes in the maps
    
    ensures (forall (pa : wap_addr_t) ::
              (status == enclave_op_success) ==>
                (excl_paddr[pa] <==> cpu_owner_map[pa] == eid));
    ensures (forall (pa : wap_addr_t) ::
              status == enclave_op_success ==> 
              (!excl_paddr[pa] ==> cpu_owner_map[pa] == old(cpu_owner_map)[pa]));
    ensures (forall (pa : wap_addr_t) ::
              status != enclave_op_success ==>
                (cpu_owner_map[pa] == old(cpu_owner_map)[pa]));
    ensures (forall (e : tap_enclave_id_t) ::
              (e != eid) ==> 
                tap_enclave_metadata_valid[e] == old(tap_enclave_metadata_valid)[e]);
    ensures (forall (e : tap_enclave_id_t) ::
              (e != eid) ==>
                tap_enclave_metadata_addr_valid[e] == old(tap_enclave_metadata_addr_valid)[e]);
    ensures (forall (e : tap_enclave_id_t) ::
              (e != eid) ==>
                tap_enclave_metadata_addr_excl[e] == old(tap_enclave_metadata_addr_excl)[e]);
    ensures (forall (e : tap_enclave_id_t) ::
              (e != eid) ==> 
                tap_enclave_metadata_addr_map[e] == old(tap_enclave_metadata_addr_map)[e]);
    ensures (forall (e : tap_enclave_id_t) ::
              (e != eid) ==>
                tap_enclave_metadata_pc[e] == old(tap_enclave_metadata_pc)[e]);
    ensures (forall (e : tap_enclave_id_t) ::
              (e != eid) ==>
                tap_enclave_metadata_entrypoint[e] == old(tap_enclave_metadata_entrypoint)[e]);
    ensures (forall (e : tap_enclave_id_t) ::
              (e != eid) ==>
                tap_enclave_metadata_regs[e] == old(tap_enclave_metadata_regs)[e]);
    ensures (forall (e : tap_enclave_id_t) ::
              (e != eid) ==>
                tap_enclave_metadata_paused[e] == old(tap_enclave_metadata_paused)[e]);
    ensures (forall (e : tap_enclave_id_t) ::
              (e != eid) ==>
                tap_enclave_metadata_cache_conflict[e] == old(tap_enclave_metadata_cache_conflict)[e]);
      
     //conditions which specify when we fail.
    
    ensures ((cpu_enclave_id == tap_null_enc_id)                                                           &&
       (valid_enclave_id(eid))                                                                       &&
       (!old(tap_enclave_metadata_valid)[eid]) /* This */                                                      &&
       (tap_addr_perm_x(addr_valid[entrypoint]))                                                     &&
       (excl_paddr[addr_map[entrypoint]])                                                            &&
       (excl_vaddr[entrypoint])                                                                      &&
       (forall (pa : wap_addr_t) :: (excl_paddr[pa] ==> old(cpu_owner_map)[pa] == tap_null_enc_id))  && /* This line */
       (forall (v : vaddr_t) :: excl_vaddr[v] ==> tap_addr_perm_v(addr_valid[v]))                       &&
       (forall (v : vaddr_t) :: excl_vaddr[v] ==> excl_paddr[addr_map[v]])                              &&
       (forall (v1, v2 : vaddr_t) :: !vaddr_alias(excl_vaddr, addr_map, v1, v2))) 
    <==> (status == enclave_op_success);
    ensures (status == enclave_op_success || status == enclave_op_invalid_arg);

    //ensures (status == enclave_op_success
    //          ==> valid_enclave_id(eid));

    
    //
    // specify what changes when we succeed
    //
    ensures (status == enclave_op_success ==> (forall (pa : wap_addr_t) ::
              (if (excl_paddr[pa]) then cpu_owner_map[pa] == eid
                                 else cpu_owner_map[pa] == old(cpu_owner_map)[pa])));
    ensures (status == enclave_op_success) ==> (forall (pa : wap_addr_t) ::
              if (excl_paddr[pa]) then cpu_owner_map[pa] == eid
                                else cpu_owner_map[pa] == old(cpu_owner_map)[pa]);
    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_valid[eid]);
    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_pc[eid] == entrypoint);
    ensures (status == enclave_op_success) ==> (tap_enclave_metadata_entrypoint[eid] == entrypoint);
    ensures (status == enclave_op_success) ==> (!tap_enclave_metadata_paused[eid]);
    ensures (status == enclave_op_success) ==> (
              (exists (p1, p2 : wap_addr_t) :: cpu_owner_map[p1] == eid &&
                                               cpu_owner_map[p2] != eid &&
                                               paddr2set(p1) == paddr2set(p2)) 
              <==> tap_enclave_metadata_cache_conflict[eid]);
    ensures (status == enclave_op_success) ==>
              (tap_enclave_metadata_regs[eid] == kzero_regs_t);
    ensures (status == enclave_op_success) ==> 
              (tap_enclave_metadata_addr_valid[eid] == addr_valid);
    ensures (status == enclave_op_success) ==>
              (tap_enclave_metadata_addr_excl[eid] == excl_vaddr);
    ensures (status == enclave_op_success) ==>
              (tap_enclave_metadata_addr_map[eid] == addr_map);

    //// additional invariants that hold upon success
    ensures (status == enclave_op_success) ==>
              (forall (v1, v2 : vaddr_t) ::
                !vaddr_alias(tap_enclave_metadata_addr_excl[eid],
                             tap_enclave_metadata_addr_map[eid], v1, v2));
    ensures (status == enclave_op_success) ==>
              (forall (v : vaddr_t) ::
                (tap_enclave_metadata_addr_excl[eid])[v] ==>
                (cpu_owner_map[(tap_enclave_metadata_addr_map[eid])[v]] == eid));
    ensures (status == enclave_op_success) ==>
              (forall (v : vaddr_t) ::
                (tap_enclave_metadata_addr_excl[eid])[v] ==>
                tap_addr_perm_v((tap_enclave_metadata_addr_valid[eid])[v]));
    modifies tap_enclave_metadata_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_excl;
    modifies tap_enclave_metadata_entrypoint;
    modifies tap_enclave_metadata_pc;
    modifies tap_enclave_metadata_regs;
    modifies tap_enclave_metadata_paused;
    modifies tap_enclave_metadata_cache_conflict;
    modifies cpu_owner_map;
  {
    var i, k             : integer;
    var mappings_alias_v : boolean;
    var paddr            : wap_addr_t;
    var va               : vaddr_t;
    var cache_conflict   : boolean;

    status = enclave_op_success;
    
    // ensure cpu mode is valid
    if (cpu_enclave_id != tap_null_enc_id) { 
       status = enclave_op_invalid_arg; 
    }
    
    // ensure eid is valid
    if (status != enclave_op_invalid_arg && 
        (!valid_enclave_id(eid)           || 
        tap_enclave_metadata_valid[eid])) {
       status = enclave_op_invalid_arg; 
    }

    // the entrypoint must be mapped and exclusive
    if (status != enclave_op_invalid_arg         &&
        !tap_addr_perm_x(addr_valid[entrypoint]) ||
        !excl_paddr[addr_map[entrypoint]]        ||
        !excl_vaddr[entrypoint]) {
       status = enclave_op_invalid_arg; 
    }

    if (status != enclave_op_invalid_arg) {
      // ensure none of the paddrs are already exclusive
      paddr = k0_wap_addr_t;
      while (LT_wapa(paddr, kmax_wap_addr_t) && status != enclave_op_invalid_arg)
        //TODO: Verification techniques for while loop
        invariant ((status != enclave_op_invalid_arg) ==>
          (forall (pa : wap_addr_t) ::
            ((LT_wapa(pa, paddr) && excl_paddr[pa]) ==>
              cpu_owner_map[pa] == tap_null_enc_id)));
        invariant ((status != enclave_op_invalid_arg) ==>
          (forall (pa : wap_addr_t) ::
            (LT_wapa(pa, paddr) ==> cpu_owner_map[pa] != eid)));
      {
        if (excl_paddr[paddr]) {
          if (cpu_owner_map[paddr] != tap_null_enc_id) {
            status = enclave_op_invalid_arg;
          }
        }
        if (cpu_owner_map[paddr] == eid) {
          status = enclave_op_invalid_arg;
        }
        paddr = PLUS_wapa(paddr, k1_wap_addr_t);
      }
    }

    if (status != enclave_op_invalid_arg) {
      if ((excl_paddr[paddr] && cpu_owner_map[paddr] != tap_null_enc_id) ||
        (cpu_owner_map[paddr] == eid))
      {
        status = enclave_op_invalid_arg;
      } else {
        // check if the private addresses alias with anything else (paddr)
        call (mappings_alias_v) = do_mappings_alias_v(excl_vaddr, addr_map);
        if (mappings_alias_v) {
          status = enclave_op_invalid_arg;
        }
      }
    }
    
    if (status != enclave_op_invalid_arg) {

      // check if the private virt addresses map to a shared phys addr
      va = k0_vaddr_t;
      while (LT_va(va, kmax_vaddr_t) && status != enclave_op_invalid_arg)
        invariant ((status != enclave_op_invalid_arg) ==> 
                      (forall (v : vaddr_t) ::
                        (LT_va(v, va) && excl_vaddr[v]) ==> excl_paddr[addr_map[v]]));
        invariant ((status != enclave_op_invalid_arg) ==> 
                      (forall (v : vaddr_t) ::
                        (LT_va(v, va) && excl_vaddr[v]) ==> tap_addr_perm_v(addr_valid[v])));
      {
        if (excl_vaddr[va])
        {
          if (!excl_paddr[addr_map[va]] || !tap_addr_perm_v(addr_valid[va]))
          {
            status = enclave_op_invalid_arg;
          }
        }
        va = PLUS_va(va, k1_vaddr_t);
      }
      if (excl_vaddr[va] &&
         (!excl_paddr[addr_map[va]] || !tap_addr_perm_v(addr_valid[va])))
      {
        status = enclave_op_invalid_arg;
      }
    }


    if (status != enclave_op_invalid_arg) {

      // Set the CPU owner map.
      paddr = k0_wap_addr_t;
      while (LT_wapa(paddr, kmax_wap_addr_t))
        invariant (forall (pa : wap_addr_t) ::
                    (LT_wapa(pa, paddr) && excl_paddr[pa]) ==>
                      cpu_owner_map[pa] == eid);
        invariant (forall (pa : wap_addr_t) ::
                    (LT_wapa(pa, paddr) && !excl_paddr[pa]) ==>
                      cpu_owner_map[pa] == old(cpu_owner_map)[pa]);
        invariant (forall (pa : wap_addr_t) ::
                    !LT_wapa (pa, paddr) ==> cpu_owner_map[pa] == old(cpu_owner_map)[pa]);
        invariant (forall (e : tap_enclave_id_t, pa : wap_addr_t) ::
                    (e != eid && e != tap_null_enc_id) ==>
                      (cpu_owner_map[pa] == e) ==> (cpu_owner_map[pa] == old(cpu_owner_map)[pa]));
      {
        if (excl_paddr[paddr]) { call update_cpu_owner_map(paddr, eid); }
        paddr = PLUS_wapa(paddr, k1_wap_addr_t);
      }
      if (excl_paddr[paddr]) { call update_cpu_owner_map(paddr, eid); }
      
      // regs are zeroed out
      call (cache_conflict) = does_enclave_conflict(eid);
      
      tap_enclave_metadata_valid[eid]           = true;
      tap_enclave_metadata_addr_map[eid]        = addr_map;
      tap_enclave_metadata_addr_valid[eid]      = addr_valid;
      tap_enclave_metadata_addr_excl[eid]       = excl_vaddr;
      tap_enclave_metadata_entrypoint[eid]      = entrypoint;
      tap_enclave_metadata_pc[eid]              = entrypoint;
      tap_enclave_metadata_regs[eid]            = kzero_regs_t;
      tap_enclave_metadata_paused[eid]          = false;
      tap_enclave_metadata_cache_conflict[eid]  = cache_conflict;
      status = enclave_op_success;
    }
  }
    
  //
  // enter an enclave
  //
  procedure [noinline] enter(eid: tap_enclave_id_t)
      returns (status : enclave_op_result_t)

      //----------------------------------------------------------------------//
      // global TAP invariants.                                               //
      //----------------------------------------------------------------------//
      requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));
      ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));

      //----------------------------------------------------------------------//
      // conditions for success or failure.                                   //
      //----------------------------------------------------------------------//
      ensures ((valid_enclave_id(eid))                   &&
               (tap_enclave_metadata_valid[eid])         &&
               (old(cpu_enclave_id) == tap_null_enc_id)) ==> (status == enclave_op_success);
      ensures ((!valid_enclave_id(eid))                  ||
               (!tap_enclave_metadata_valid[eid])        ||
               (old(cpu_enclave_id) != tap_null_enc_id)) ==> (status == enclave_op_invalid_arg);
      ensures (status == enclave_op_success || status == enclave_op_invalid_arg);
                  
      //----------------------------------------------------------------------//
      // nothing changes on failure.                                          //
      //----------------------------------------------------------------------//
      ensures (status != enclave_op_success ==> cpu_enclave_id == old(cpu_enclave_id));
      ensures (status != enclave_op_success ==> cpu_addr_valid == old(cpu_addr_valid));
      ensures (status != enclave_op_success ==> (cpu_addr_map == old(cpu_addr_map)));
      ensures (status != enclave_op_success ==> cpu_pc == old(cpu_pc));
      ensures (status != enclave_op_success ==> untrusted_regs == old(untrusted_regs));
      ensures (status != enclave_op_success ==> untrusted_addr_valid == old(untrusted_addr_valid));
      ensures (status != enclave_op_success ==> untrusted_addr_map == old(untrusted_addr_map));
      ensures (status != enclave_op_success ==> untrusted_pc == old(untrusted_pc));

      //----------------------------------------------------------------------//
      // state updates on success.                                            //
      //----------------------------------------------------------------------//
      ensures (status == enclave_op_success) ==> (untrusted_pc == old(cpu_pc));
      ensures (status == enclave_op_success) ==> (cpu_enclave_id == eid);
      ensures (status == enclave_op_success) ==> (cpu_pc == tap_enclave_metadata_entrypoint[eid]);
      ensures (status == enclave_op_success) ==> (untrusted_regs == old(cpu_regs));
      ensures (status == enclave_op_success) ==> (untrusted_addr_valid == old(cpu_addr_valid));
      ensures (status == enclave_op_success) ==> (untrusted_addr_map == old(cpu_addr_map));
      ensures (status == enclave_op_success) ==> (cpu_addr_valid == tap_enclave_metadata_addr_valid[eid]);
      ensures (status == enclave_op_success) ==> (cpu_addr_map == tap_enclave_metadata_addr_map[eid]);
      ensures (tap_addr_perm_x(old(cpu_addr_valid)[old(cpu_pc)])
                ==> (status == enclave_op_success
                      ==> tap_addr_perm_x(untrusted_addr_valid[untrusted_pc])));    
      ensures (cpu_regs == old(cpu_regs));


      modifies untrusted_regs;
      modifies untrusted_addr_valid;
      modifies untrusted_addr_map;
      modifies untrusted_pc;
      modifies cpu_enclave_id;
      modifies cpu_addr_map;
      modifies cpu_addr_valid;
      modifies cpu_pc;
      modifies cpu_regs;
  {
      // no enclave id is null
      // enclave must be valid and not baused
      // cpu must be ready to execute enclaves
      if (!valid_enclave_id(eid)              ||
          !tap_enclave_metadata_valid[eid]    ||
          cpu_enclave_id != tap_null_enc_id)
      {
        status = enclave_op_invalid_arg;
      } else {
        status                  = enclave_op_success;
        // save context
        untrusted_regs          = cpu_regs;
        untrusted_addr_valid    = cpu_addr_valid;
        untrusted_addr_map      = cpu_addr_map;
        untrusted_pc            = cpu_pc;
        // restore enclave context
        call set_cpu_state(eid,
                           tap_enclave_metadata_addr_map[eid],
                           tap_enclave_metadata_addr_valid[eid],
                           tap_enclave_metadata_entrypoint[eid],
                           cpu_regs);
      }
  }

  //
  // Resume an enclave
  //
  procedure [noinline]  resume(eid: tap_enclave_id_t)
      returns (status : enclave_op_result_t)

      //----------------------------------------------------------------------//
      // global TAP invariants.                                               //
      //----------------------------------------------------------------------//
      requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));
      ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));

      //----------------------------------------------------------------------//
      // conditions for success or failure.                                   //
      //----------------------------------------------------------------------//
      ensures ((valid_enclave_id(eid))                      &&
               (tap_enclave_metadata_valid[eid])            && 
               (tap_enclave_metadata_paused[eid])           &&
               (old(cpu_enclave_id) == tap_null_enc_id))    ==> (status == enclave_op_success);
      ensures ((!valid_enclave_id(eid))                     ||
               (!tap_enclave_metadata_valid[eid])           || 
               (!tap_enclave_metadata_paused[eid])          ||
               (old(cpu_enclave_id) != tap_null_enc_id))    ==> (status == enclave_op_invalid_arg);
      ensures (status == enclave_op_success || status == enclave_op_invalid_arg);

      //----------------------------------------------------------------------//
      // nothing changes on failure.                                          //
      //----------------------------------------------------------------------//
      ensures (status != enclave_op_success ==> cpu_regs == old(cpu_regs));
      ensures (status != enclave_op_success ==> cpu_enclave_id == old(cpu_enclave_id));
      ensures (status != enclave_op_success ==> cpu_addr_valid == old(cpu_addr_valid));
      ensures (status != enclave_op_success ==> cpu_addr_map == old(cpu_addr_map));
      ensures (status != enclave_op_success ==> cpu_pc == old(cpu_pc));
      ensures (status != enclave_op_success ==> untrusted_regs == old(untrusted_regs));
      ensures (status != enclave_op_success ==> untrusted_addr_valid == old(untrusted_addr_valid));
      ensures (status != enclave_op_success ==> untrusted_addr_map == old(untrusted_addr_map));
      ensures (status != enclave_op_success ==> untrusted_pc == old(untrusted_pc));

      //----------------------------------------------------------------------//
      // state updates on success.                                            //
      //----------------------------------------------------------------------//
      ensures (status == enclave_op_success) ==> (untrusted_pc == old(cpu_pc));
      ensures (status == enclave_op_success) ==> (cpu_enclave_id == eid);
      ensures (status == enclave_op_success) ==> (cpu_pc == tap_enclave_metadata_pc[eid]);
      ensures (status == enclave_op_success) ==> (untrusted_regs == old(cpu_regs));
      ensures (status == enclave_op_success) ==> (untrusted_addr_valid == old(cpu_addr_valid));
      ensures (status == enclave_op_success) ==> (untrusted_addr_map == old(cpu_addr_map));
      ensures (status == enclave_op_success) ==> (cpu_regs == tap_enclave_metadata_regs[eid]);
      ensures (status == enclave_op_success) ==> (cpu_addr_valid == tap_enclave_metadata_addr_valid[eid]);
      ensures (status == enclave_op_success) ==> (cpu_addr_map == tap_enclave_metadata_addr_map[eid]);
      ensures (tap_addr_perm_x(old(cpu_addr_valid)[old(cpu_pc)])
                ==> (status == enclave_op_success
                      ==> tap_addr_perm_x(untrusted_addr_valid[untrusted_pc])));

      modifies untrusted_regs;
      modifies untrusted_addr_valid;
      modifies untrusted_addr_map;
      modifies untrusted_pc;
      modifies cpu_enclave_id;
      modifies cpu_addr_map;
      modifies cpu_addr_valid;
      modifies cpu_pc;
      modifies cpu_regs;
  {
    if (!valid_enclave_id(eid)              ||
        !tap_enclave_metadata_valid[eid]    ||
        !tap_enclave_metadata_paused[eid]   ||
        cpu_enclave_id != tap_null_enc_id) 
    {
      status = enclave_op_invalid_arg;
    } else {
      // save context
      untrusted_regs                = cpu_regs;
      untrusted_addr_valid          = cpu_addr_valid;
      untrusted_addr_map            = cpu_addr_map;
      untrusted_pc                  = cpu_pc;
      // restore enclave context
      call set_cpu_state(eid,
                         tap_enclave_metadata_addr_map[eid],
                         tap_enclave_metadata_addr_valid[eid],
                         tap_enclave_metadata_pc[eid],
                         tap_enclave_metadata_regs[eid]);
      status = enclave_op_success;
    }
  }

  // -------------------------------------------------------------------- //
  // Exit an enclave.                                                     //
  // -------------------------------------------------------------------- //
  procedure [noinline]  exit()
      returns (status : enclave_op_result_t)

      //----------------------------------------------------------------------//
      // global TAP invariants.                                               //
      //----------------------------------------------------------------------//
      requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));
      ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));
                 
      //----------------------------------------------------------------------//
      // success/failure conditions.                                          //
      //----------------------------------------------------------------------//
      ensures (old(cpu_enclave_id) == tap_null_enc_id) ==> (status == enclave_op_failed);
      ensures (old(cpu_enclave_id) != tap_null_enc_id) ==> (status == enclave_op_success);
      ensures (status == enclave_op_success || status == enclave_op_failed);

      //----------------------------------------------------------------------//
      // nothing changes on failure.                                          //
      //----------------------------------------------------------------------//
      ensures (status != enclave_op_success ==> cpu_regs == old(cpu_regs));
      ensures (status != enclave_op_success ==> cpu_enclave_id == old(cpu_enclave_id));
      ensures (status != enclave_op_success ==> cpu_addr_valid == old(cpu_addr_valid));
      ensures (status != enclave_op_success ==> cpu_addr_map == old(cpu_addr_map));
      ensures (status != enclave_op_success ==> cpu_pc == old(cpu_pc));
      ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_valid == old(tap_enclave_metadata_addr_valid));
      ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_map == old(tap_enclave_metadata_addr_map));
      ensures (status != enclave_op_success ==> tap_enclave_metadata_pc == old(tap_enclave_metadata_pc));
      ensures (status != enclave_op_success ==> tap_enclave_metadata_paused == old(tap_enclave_metadata_paused));
      // nothing except eid changes for paused, pc, addr_valid and addr_map
      ensures (forall (e : tap_enclave_id_t) :: 
          e != old(cpu_enclave_id) ==> 
              (tap_enclave_metadata_paused[e] == old(tap_enclave_metadata_paused)[e]));
      ensures (forall (e : tap_enclave_id_t) :: 
          e != old(cpu_enclave_id) ==> 
              (tap_enclave_metadata_pc[e] == old(tap_enclave_metadata_pc)[e]));
      ensures (forall (e : tap_enclave_id_t) ::
          e != old(cpu_enclave_id) ==>
              tap_enclave_metadata_addr_valid[e] == old(tap_enclave_metadata_addr_valid)[e]);
      ensures (forall (e : tap_enclave_id_t) ::
          e != old(cpu_enclave_id) ==>
              tap_enclave_metadata_addr_map[e] == old(tap_enclave_metadata_addr_map)[e]);

      //----------------------------------------------------------------------//
      // state updates on success.                                            //
      //----------------------------------------------------------------------//
      ensures (status == enclave_op_success) ==> (cpu_pc == untrusted_pc);
      ensures (status == enclave_op_success) ==> (cpu_enclave_id == tap_null_enc_id);
      ensures (status == enclave_op_success) ==> (!tap_enclave_metadata_paused[old(cpu_enclave_id)]);
      ensures (status == enclave_op_success) ==> 
              (tap_enclave_metadata_pc[old(cpu_enclave_id)] == tap_enclave_metadata_entrypoint[old(cpu_enclave_id)]);
      ensures (status == enclave_op_success) ==>
                (tap_enclave_metadata_addr_valid[old(cpu_enclave_id)] == old(cpu_addr_valid));
      ensures (status == enclave_op_success) ==>
                (tap_enclave_metadata_addr_map[old(cpu_enclave_id)] == old(cpu_addr_map));
      ensures (status == enclave_op_success) ==> (cpu_regs == untrusted_regs);
      ensures (status == enclave_op_success) ==> (cpu_addr_valid == untrusted_addr_valid);
      ensures (status == enclave_op_success) ==> (cpu_addr_map == untrusted_addr_map);
      ensures (tap_addr_perm_x(untrusted_addr_valid[untrusted_pc])
                ==> (status == enclave_op_success 
                      ==> tap_addr_perm_x(cpu_addr_valid[cpu_pc])));
      ensures (status == enclave_op_success
                ==> (cpu_owner_map[untrusted_addr_map[untrusted_pc]]
                      == cpu_owner_map[cpu_addr_map[cpu_pc]]));



      modifies tap_enclave_metadata_addr_valid;
      modifies tap_enclave_metadata_addr_map;
      modifies tap_enclave_metadata_pc;
      modifies tap_enclave_metadata_paused;
      modifies cpu_enclave_id;
      modifies cpu_addr_map;
      modifies cpu_addr_valid;
      modifies cpu_pc;
      modifies cpu_regs;
  {
    var eid : tap_enclave_id_t;
    
    if (cpu_enclave_id == tap_null_enc_id) {
      status = enclave_op_failed;
    } else {
      status = enclave_op_success;

      eid                                   = cpu_enclave_id;
      tap_enclave_metadata_addr_valid[eid]  = cpu_addr_valid;
      tap_enclave_metadata_addr_map[eid]    = cpu_addr_map;
      tap_enclave_metadata_pc[eid]          = tap_enclave_metadata_entrypoint[eid];
      tap_enclave_metadata_paused[eid]      = false;
      
      call set_cpu_state(tap_null_enc_id,
                             untrusted_addr_map,
                             untrusted_addr_valid,
                             untrusted_pc,
                             untrusted_regs);
      status = enclave_op_success;
    }
  }

  //
  // Pause an enclave
  //
  procedure [noinline]  pause()
      returns (status : enclave_op_result_t)

      //----------------------------------------------------------------------//
      // global TAP invariants.                                               //
      //----------------------------------------------------------------------//
      requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));
      ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));
      //----------------------------------------------------------------------//
      // success/failure conditions.                                          //
      //----------------------------------------------------------------------//
      ensures (old(cpu_enclave_id) == tap_null_enc_id) ==> (status == enclave_op_failed);
      ensures (old(cpu_enclave_id) != tap_null_enc_id) ==> (status == enclave_op_success);
      ensures (status == enclave_op_success || status == enclave_op_failed);
                 
      //----------------------------------------------------------------------//
      // nothing changes on failure.                                          //
      //----------------------------------------------------------------------//
      ensures (status != enclave_op_success ==> cpu_regs == old(cpu_regs));
      ensures (status != enclave_op_success ==> cpu_enclave_id == old(cpu_enclave_id));
      ensures (status != enclave_op_success ==> cpu_addr_valid == old(cpu_addr_valid));
      ensures (status != enclave_op_success ==> cpu_addr_map == old(cpu_addr_map));
      ensures (status != enclave_op_success ==> cpu_pc == old(cpu_pc));
      ensures (status != enclave_op_success ==> tap_enclave_metadata_regs == old(tap_enclave_metadata_regs));
      ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_valid == old(tap_enclave_metadata_addr_valid));
      ensures (status != enclave_op_success ==> tap_enclave_metadata_addr_map == old(tap_enclave_metadata_addr_map));
      ensures (status != enclave_op_success ==> tap_enclave_metadata_pc == old(tap_enclave_metadata_pc));
      ensures (status != enclave_op_success ==> tap_enclave_metadata_paused == old(tap_enclave_metadata_paused));
      // nothing except eid changes for paused, pc, regs, addr_valid and addr_map
      ensures (forall (e : tap_enclave_id_t) :: 
          e != old(cpu_enclave_id) ==> 
              (tap_enclave_metadata_paused[e] == old(tap_enclave_metadata_paused)[e]));
      ensures (forall (e : tap_enclave_id_t) :: 
          e != old(cpu_enclave_id) ==> 
              (tap_enclave_metadata_pc[e] == old(tap_enclave_metadata_pc)[e]));
      ensures (forall (e : tap_enclave_id_t) ::
          e != old(cpu_enclave_id) ==>
              tap_enclave_metadata_regs[e] == old(tap_enclave_metadata_regs)[e]);
      ensures (forall (e : tap_enclave_id_t) ::
          e != old(cpu_enclave_id) ==>
              tap_enclave_metadata_addr_valid[e] == old(tap_enclave_metadata_addr_valid)[e]);
      ensures (forall (e : tap_enclave_id_t) ::
          e != old(cpu_enclave_id) ==>
              tap_enclave_metadata_addr_map[e] == old(tap_enclave_metadata_addr_map)[e]);

      //----------------------------------------------------------------------//
      // state updates on success.                                            //
      //----------------------------------------------------------------------//
      ensures (status == enclave_op_success) ==> (cpu_pc == untrusted_pc);
      ensures (status == enclave_op_success) ==> (cpu_enclave_id == tap_null_enc_id);
      ensures (status == enclave_op_success) ==> (tap_enclave_metadata_paused[old(cpu_enclave_id)]);
      ensures (status == enclave_op_success) ==> 
              (tap_enclave_metadata_pc[old(cpu_enclave_id)] == old(cpu_pc));
      ensures (status == enclave_op_success) ==>
              (tap_enclave_metadata_regs[old(cpu_enclave_id)] == old(cpu_regs));
      ensures (status == enclave_op_success) ==>
                (tap_enclave_metadata_addr_valid[old(cpu_enclave_id)] == old(cpu_addr_valid));
      ensures (status == enclave_op_success) ==>
                (tap_enclave_metadata_addr_map[old(cpu_enclave_id)] == old(cpu_addr_map));
      ensures (status == enclave_op_success) ==>
              (cpu_regs == untrusted_regs);
      ensures (status == enclave_op_success) ==>
              (cpu_addr_valid == untrusted_addr_valid);
      ensures (status == enclave_op_success) ==>
              (cpu_addr_map == untrusted_addr_map);
      ensures (tap_addr_perm_x(untrusted_addr_valid[untrusted_pc])
                ==> (status == enclave_op_success 
                      ==> tap_addr_perm_x(cpu_addr_valid[cpu_pc])));
      ensures (status == enclave_op_success
                ==> (cpu_owner_map[untrusted_addr_map[untrusted_pc]]
                      == cpu_owner_map[cpu_addr_map[cpu_pc]]));

      modifies tap_enclave_metadata_regs;
      modifies tap_enclave_metadata_addr_valid;
      modifies tap_enclave_metadata_addr_map;
      modifies tap_enclave_metadata_pc;
      modifies tap_enclave_metadata_paused;
      modifies cpu_enclave_id;
      modifies cpu_addr_map;
      modifies cpu_addr_valid;
      modifies cpu_pc;
      modifies cpu_regs;
  {
    var eid : tap_enclave_id_t;
      
    if (cpu_enclave_id == tap_null_enc_id) {
      status = enclave_op_failed;
    } else {
      eid                                  = cpu_enclave_id;
      tap_enclave_metadata_regs[eid]       = cpu_regs;
      tap_enclave_metadata_addr_valid[eid] = cpu_addr_valid;
      tap_enclave_metadata_addr_map[eid]   = cpu_addr_map;
      tap_enclave_metadata_pc[eid]         = cpu_pc;
      tap_enclave_metadata_paused[eid]     = true;

      call set_cpu_state(tap_null_enc_id,
                             untrusted_addr_map,
                             untrusted_addr_valid,
                             untrusted_pc,
                             untrusted_regs);
      status = enclave_op_success;
    }
  }

  //
  // Destroy an enclave
  //
  procedure [noinline]  destroy(eid: tap_enclave_id_t)
      returns (status: enclave_op_result_t)

      //----------------------------------------------------------------------//
      // global TAP invariants.                                               //
      //----------------------------------------------------------------------//
      requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));
      ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));

      //----------------------------------------------------------------------//
      // success/failure conditions.                                          //
      //----------------------------------------------------------------------//
      ensures (!valid_enclave_id(eid)                 || 
               !old(tap_enclave_metadata_valid)[eid]  || 
               cpu_enclave_id != tap_null_enc_id) ==> (status == enclave_op_invalid_arg);
      ensures (valid_enclave_id(eid)                  && 
               old(tap_enclave_metadata_valid)[eid]   && 
               cpu_enclave_id == tap_null_enc_id) ==> (status == enclave_op_success);
      ensures (status == enclave_op_success || status == enclave_op_invalid_arg);

      //----------------------------------------------------------------------//
      // nothing changes on failure.                                          //
      //----------------------------------------------------------------------//
      ensures (status != enclave_op_success ==> cpu_owner_map == old(cpu_owner_map));
      ensures (status != enclave_op_success ==> cpu_pc == old(cpu_pc));
      ensures (status != enclave_op_success ==> tap_enclave_metadata_regs == old(tap_enclave_metadata_regs));
      ensures (status != enclave_op_success ==> tap_enclave_metadata_valid == old(tap_enclave_metadata_valid));
      ensures (status != enclave_op_success ==> tap_enclave_metadata_pc == old(tap_enclave_metadata_pc));
      // regs don't change except for eid.
      ensures (forall (e : tap_enclave_id_t) ::
                  (e != eid) ==> tap_enclave_metadata_regs[e] == old(tap_enclave_metadata_regs)[e]);

      //----------------------------------------------------------------------//
      // status updates on success                                            //
      //----------------------------------------------------------------------//
      ensures (status == enclave_op_success) ==>
                  (forall (p : wap_addr_t) ::
                      (if (old(cpu_owner_map)[p] == eid)
                          then (cpu_owner_map[p] == tap_blocked_enc_id)
                          else (cpu_owner_map[p] == old(cpu_owner_map)[p])));
      ensures (status == enclave_op_success) ==>
                  (forall (p : wap_addr_t) ::
                      old(cpu_owner_map)[p] == eid ==>
                          (cpu_owner_map[p] == tap_blocked_enc_id));
      ensures (status == enclave_op_success) ==>
                  (forall (p : wap_addr_t) ::
                      old(cpu_owner_map)[p] != eid ==> 
                          cpu_owner_map[p] == old(cpu_owner_map)[p]);
      ensures (status == enclave_op_success) ==>
                  (forall (e : tap_enclave_id_t) :: 
                      tap_enclave_metadata_valid[e] == 
                          (if (e == eid) then false
                                       else old(tap_enclave_metadata_valid)[e]));
      ensures (status == enclave_op_success) ==>
                  (forall (e : tap_enclave_id_t) :: 
                      tap_enclave_metadata_pc[e] == 
                          (if (e == eid) then k0_vaddr_t
                                       else old(tap_enclave_metadata_pc)[e]));
      ensures (status == enclave_op_success) ==>
                  (tap_enclave_metadata_regs[eid] == kzero_regs_t);

      modifies tap_enclave_metadata_regs;
      modifies tap_enclave_metadata_valid;
      modifies tap_enclave_metadata_pc;
      modifies cpu_owner_map;
  {
    var va : wap_addr_t;
    var pa : wap_addr_t;
    // no enclave_id is null
    if (!valid_enclave_id(eid) || !tap_enclave_metadata_valid[eid] || cpu_enclave_id != tap_null_enc_id) {
      status = enclave_op_invalid_arg;
    } else {

      assert (cpu_enclave_id != eid);
      assert tap_enclave_metadata_valid[eid];

      // we have to clear out the enclave's registers and memory.
      pa = k0_wap_addr_t;
      while (LT_wapa(pa, kmax_wap_addr_t))
        invariant (forall (p : wap_addr_t) ::
                    LT_wapa(p, pa) ==>
                      (if (old(cpu_owner_map)[p] == eid)
                          then (cpu_owner_map[p] == tap_blocked_enc_id)
                          else (cpu_owner_map[p] == old(cpu_owner_map)[p])));
        invariant (forall (p : wap_addr_t) ::
                    (!LT_wapa(p, pa) ==> 
                      (cpu_owner_map[p] == old(cpu_owner_map)[p])));
      {
        if (cpu_owner_map[pa] == eid) {
          call update_cpu_owner_map(pa, tap_blocked_enc_id);
        }
        pa = PLUS_wapa(pa, k1_wap_addr_t);
      }
      if (cpu_owner_map[kmax_wap_addr_t] == eid) {
        call update_cpu_owner_map(kmax_wap_addr_t, tap_blocked_enc_id);
      }
      assert (forall (p : wap_addr_t) ::
                (if (old(cpu_owner_map)[p] == eid)
                    then (cpu_owner_map[p] == tap_blocked_enc_id)
                    else (cpu_owner_map[p] == old(cpu_owner_map)[p])));
      assert (forall (p : wap_addr_t) ::
                (old(cpu_owner_map)[p] == eid) ==> 
                  (cpu_owner_map[p] == tap_blocked_enc_id));
      assert (forall (p : wap_addr_t) ::
                (old(cpu_owner_map)[p] != eid) ==>
                  (cpu_owner_map[p] == old(cpu_owner_map)[p]));
      assert (forall (p : wap_addr_t) ::
                (old(cpu_owner_map)[p] != eid) ==> cpu_mem[p] == old(cpu_mem)[p]);

      // and now we mark the enclave invalid
      tap_enclave_metadata_valid[eid] = false;
      tap_enclave_metadata_regs[eid]  = kzero_regs_t;
      tap_enclave_metadata_pc[eid]    = k0_vaddr_t;
      
      status = enclave_op_success;
    }
  }

  //
  // Block available memory
  //
  procedure [noinline] block_memory_region(bmap : excl_map_t)
     returns (status : enclave_op_result_t)

      //----------------------------------------------------------------------//
      // global TAP invariants.                                               //
      //----------------------------------------------------------------------//
      requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));
      ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));

      // success condition.
      ensures ((forall (p : wap_addr_t) ::
                  bmap[p] ==> (old(cpu_owner_map)[p] == tap_null_enc_id))
              <==> (status == enclave_op_success));
      ensures (status == enclave_op_success || status == enclave_op_invalid_arg);

      // effect on cpu_owner_map
      ensures (status == enclave_op_success) ==>
              (forall (p : wap_addr_t) :: 
                  if (bmap[p]) 
                      then cpu_owner_map[p] == tap_blocked_enc_id
                      else cpu_owner_map[p] == old(cpu_owner_map)[p]);
      ensures (status != enclave_op_success) ==> 
                  old(cpu_owner_map) == cpu_owner_map;

      modifies cpu_owner_map;
  {
    var pa : wap_addr_t;
    // First make sure that all the addresses in bmap are blocked
    pa = k0_wap_addr_t;

    //Ensures that we dont simply terminate initially
    status = enclave_op_success;

    while (LT_wapa(pa, kmax_wap_addr_t) && status != enclave_op_invalid_arg)
      invariant ((status != enclave_op_invalid_arg) ==> 
                  (forall (p : wap_addr_t) ::
                    (LT_wapa(p, pa) && bmap[p]) ==> (cpu_owner_map[p] == tap_null_enc_id)));
    {
      if (bmap[pa] && (cpu_owner_map[pa] != tap_null_enc_id)) {
        status = enclave_op_invalid_arg;
      }
      
      pa = PLUS_wapa(pa, k1_wap_addr_t);
    }

    
    if ((status != enclave_op_invalid_arg) && bmap[pa] && (cpu_owner_map[pa] != tap_null_enc_id)) {
        status = enclave_op_invalid_arg;
    }
    
    if (status != enclave_op_invalid_arg) {
      assert (forall (p : wap_addr_t) :: bmap[p] ==> (cpu_owner_map[p] == tap_null_enc_id));

      // NOw go around clearing each address in bmap
      pa = k0_wap_addr_t;
      while (LT_wapa(pa, kmax_wap_addr_t))
        invariant (forall (p : wap_addr_t) :: bmap[p] ==>
                    (if (LT_wapa(p, pa))
                         then cpu_owner_map[p] == tap_blocked_enc_id
                         else cpu_owner_map[p] == tap_null_enc_id));
        invariant (forall (p : wap_addr_t) ::
                    (if (LT_wapa(p, pa) && bmap[p])
                         then cpu_owner_map[p] == tap_blocked_enc_id
                         else cpu_owner_map[p] == old(cpu_owner_map)[p]));
      {
        if (bmap[pa]) {
          call update_cpu_owner_map(pa, tap_blocked_enc_id);
        }
        pa = PLUS_wapa(pa, k1_wap_addr_t);
      }
      if (bmap[pa]) {
        call update_cpu_owner_map(pa, tap_blocked_enc_id);
      }
      assert (forall (p : wap_addr_t) ::
              if (bmap[p])
                 then (cpu_owner_map[p] == tap_blocked_enc_id)
                 else (cpu_owner_map[p] == old(cpu_owner_map)[p]));
      status = enclave_op_success;
    }
  }


  //
  // Reclaim blocked memory
  //
  procedure [noinline] release_blocked_memory(bmap : excl_map_t)
      returns (status : enclave_op_result_t)

      //----------------------------------------------------------------------//
      // global TAP invariants.                                               //
      //----------------------------------------------------------------------//
      requires (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));
      ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));

      // success condition.
      ensures ((forall (p : wap_addr_t) ::
                  bmap[p] ==> (old(cpu_owner_map)[p] == tap_blocked_enc_id))
              <==> (status == enclave_op_success));
      ensures (status == enclave_op_success || status == enclave_op_invalid_arg);

      // effect on cpu_owner_map
      ensures (status == enclave_op_success) ==>
              (forall (p : wap_addr_t) :: 
                  if (bmap[p])
                      then (cpu_owner_map[p] == tap_null_enc_id && 
                            cpu_mem[p] == k0_word_t)
                      else (cpu_owner_map[p] == old(cpu_owner_map)[p] && 
                            cpu_mem[p] == old(cpu_mem)[p]));
      ensures (status != enclave_op_success) ==> 
                  (old(cpu_owner_map) == cpu_owner_map &&
                   old(cpu_mem) == cpu_mem);

      modifies cpu_owner_map;
      modifies cpu_mem;
  {
    var pa : wap_addr_t;
    // First make sure that all the addresses in bmap are blocked
    pa = k0_wap_addr_t;

    //Ensures that we dont simply terminate initially
    status = enclave_op_success;


    while (LT_wapa(pa, kmax_wap_addr_t) && status != enclave_op_invalid_arg)
      invariant ((status != enclave_op_invalid_arg) ==>
                    (forall (p : wap_addr_t) ::
                      (LT_wapa(p, pa) && bmap[p]) ==> (cpu_owner_map[p] == tap_blocked_enc_id)));
    
    {
      if (bmap[pa] && cpu_owner_map[pa] != tap_blocked_enc_id) {
        status = enclave_op_invalid_arg;
      }
      pa = PLUS_wapa(pa, k1_wap_addr_t);
    }
    if (status != enclave_op_invalid_arg && bmap[pa] && cpu_owner_map[pa] != tap_blocked_enc_id) {
      status = enclave_op_invalid_arg;
    }

    if (status != enclave_op_invalid_arg) {
      assert (forall (p : wap_addr_t) :: bmap[p] ==> (cpu_owner_map[p] == tap_blocked_enc_id));

      // Now go around clearing each address in bmap
      pa = k0_wap_addr_t;
      while (LT_wapa(pa, kmax_wap_addr_t))
        invariant (forall (p : wap_addr_t) :: bmap[p] ==>
                    (if (LT_wapa(p, pa))
                        then cpu_owner_map[p] == tap_null_enc_id
                        else cpu_owner_map[p] == tap_blocked_enc_id));
        invariant (forall (p : wap_addr_t) ::
                    if (LT_wapa(p, pa) && bmap[p])
                        then (cpu_owner_map[p] == tap_null_enc_id && cpu_mem[p] == k0_word_t)
                        else (cpu_owner_map[p] == old(cpu_owner_map)[p] && cpu_mem[p] == old(cpu_mem)[p]));
      {
        if (bmap[pa]) {
          call update_cpu_owner_map(pa, tap_null_enc_id);
          call update_cpu_mem(pa, k0_word_t);
        }
        pa = PLUS_wapa(pa, k1_wap_addr_t);
      }
      if (bmap[pa]) {
        call update_cpu_owner_map(pa, tap_null_enc_id);
        call update_cpu_mem(pa, k0_word_t);

      }
      assert (forall (p : wap_addr_t) ::
                if (bmap[p])
                   then (cpu_owner_map[p] == tap_null_enc_id && cpu_mem[p] == k0_word_t)
                   else (cpu_owner_map[p] == old(cpu_owner_map)[p] && cpu_mem[p] == old(cpu_mem)[p]));
      status = enclave_op_success;
    }
  }

  //
  // Proof support
  // 

  //
  // For refinement proof
  //
  procedure  [inline] cpu_fetch_va(vaddr : vaddr_t, repl_way : cache_way_index_t) 
      returns (data : word_t, excp : exception_t, hit : boolean)
      modifies cpu_addr_valid;
      modifies cache_valid_map, cache_tag_map;
  {
      call (data, excp, hit) = fetch_va(vaddr, repl_way);
  }

  procedure [inline] cpu_load_va(vaddr : vaddr_t, repl_way : cache_way_index_t)
      returns (data : word_t, excp : exception_t, hit : boolean)
      modifies cpu_addr_valid;
      modifies cache_valid_map, cache_tag_map;
  {
      call (data, excp, hit) = load_va(vaddr, repl_way);
  }

  procedure [inline] cpu_store_va(vaddr : vaddr_t, data : word_t, repl_way : cache_way_index_t)
    returns (excp : exception_t, hit : boolean)
    modifies cpu_mem;
    modifies cpu_addr_valid;
    modifies cache_valid_map, cache_tag_map;
  {
      call (excp, hit) = store_va(vaddr, data, repl_way);
  }

  //======================================================================//
  // PROOF PROCEDURES                                                     //
  //======================================================================//

  //
  // Common Procedures found in ImplCommon.bpl
  //
  procedure [inline] tap_addr_valid_proofs()
  {
      // setting the present bit does not affect the axrw bits.
      assert (forall (p : addr_perm_t) :: tap_addr_perm_p(tap_set_addr_perm_p(p)));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_a(tap_set_addr_perm_p(p)) == tap_addr_perm_a(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_x(tap_set_addr_perm_p(p)) == tap_addr_perm_x(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_r(tap_set_addr_perm_p(p)) == tap_addr_perm_r(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_w(tap_set_addr_perm_p(p)) == tap_addr_perm_w(p));
      // setting the a bit does not affect the pxrw bits.
      assert (forall (p : addr_perm_t) :: tap_addr_perm_a(tap_set_addr_perm_a(p)));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_p(tap_set_addr_perm_a(p)) == tap_addr_perm_p(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_x(tap_set_addr_perm_a(p)) == tap_addr_perm_x(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_r(tap_set_addr_perm_a(p)) == tap_addr_perm_r(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_w(tap_set_addr_perm_a(p)) == tap_addr_perm_w(p));
      // setting the x bit does not affect parw.
      assert (forall (p : addr_perm_t) :: tap_addr_perm_x(tap_set_addr_perm_x(p)));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_p(tap_set_addr_perm_x(p)) == tap_addr_perm_p(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_a(tap_set_addr_perm_x(p)) == tap_addr_perm_a(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_r(tap_set_addr_perm_x(p)) == tap_addr_perm_r(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_w(tap_set_addr_perm_x(p)) == tap_addr_perm_w(p));
      // setting the r bit does not affect paxw.
      assert (forall (p : addr_perm_t) :: tap_addr_perm_r(tap_set_addr_perm_r(p)));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_p(tap_set_addr_perm_r(p)) == tap_addr_perm_p(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_a(tap_set_addr_perm_x(p)) == tap_addr_perm_a(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_x(tap_set_addr_perm_r(p)) == tap_addr_perm_x(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_w(tap_set_addr_perm_r(p)) == tap_addr_perm_w(p));
      // setting the w bit does not affect pax:.
      assert (forall (p : addr_perm_t) :: tap_addr_perm_w(tap_set_addr_perm_w(p)));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_p(tap_set_addr_perm_w(p)) == tap_addr_perm_p(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_a(tap_set_addr_perm_x(p)) == tap_addr_perm_a(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_x(tap_set_addr_perm_w(p)) == tap_addr_perm_x(p));
      assert (forall (p : addr_perm_t) :: tap_addr_perm_r(tap_set_addr_perm_w(p)) == tap_addr_perm_r(p));
      // tap_addr_perm_eq
      assert (forall (p1, p2 : addr_perm_t) :: (tap_addr_perm_eq(p1, p2)) <==>
                                             (tap_addr_perm_bits(p1) == tap_addr_perm_bits(p2)));
  }

  procedure [noinline] InitialHavoc()
      returns (current_mode : mode_t)
      ensures (current_mode == mode_untrusted);
      //----------------------------------------------------------------------//
      // global TAP invariants.                                               //
      //----------------------------------------------------------------------//
      ensures (cpu_enclave_id == tap_null_enc_id);
      ensures  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                  (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                      (cpu_owner_map[pa] != e));
      // current pc invariants
      ensures (tap_addr_perm_x(cpu_addr_valid[cpu_pc]));
      ensures (cpu_owner_map[cpu_addr_map[cpu_pc]] == cpu_enclave_id);
      // enclave invariants.
      ensures (forall (e : tap_enclave_id_t) :: !valid_enclave_id(e) ==> !tap_enclave_metadata_valid[e]);
      ensures (forall (e : tap_enclave_id_t) ::
                  tap_enclave_metadata_valid[e] ==> 
                      tap_addr_perm_x((tap_enclave_metadata_addr_valid[e])[tap_enclave_metadata_pc[e]]));
      ensures (forall (e : tap_enclave_id_t) ::
                  tap_enclave_metadata_valid[e] ==> 
                      tap_addr_perm_x((tap_enclave_metadata_addr_valid[e])[tap_enclave_metadata_entrypoint[e]]));
      ensures (forall (e : tap_enclave_id_t) ::
                  tap_enclave_metadata_valid[e] ==> 
                      (tap_enclave_metadata_addr_excl[e])[tap_enclave_metadata_pc[e]]);
      ensures (forall (e : tap_enclave_id_t) ::
                  tap_enclave_metadata_valid[e] ==> 
                      (tap_enclave_metadata_addr_excl[e])[tap_enclave_metadata_entrypoint[e]]);
      ensures (forall (e : tap_enclave_id_t) ::
                  tap_enclave_metadata_valid[e] ==> 
                      cpu_owner_map[(tap_enclave_metadata_addr_map[e])[tap_enclave_metadata_pc[e]]] == e);
      ensures (forall (e : tap_enclave_id_t) ::
                  tap_enclave_metadata_valid[e] ==> 
                      cpu_owner_map[(tap_enclave_metadata_addr_map[e])[tap_enclave_metadata_entrypoint[e]]] == e);
      // CPU/Enclave address map invariants.
      ensures (forall (va : vaddr_t) :: 
                  (cpu_enclave_id == tap_null_enc_id) ==> 
                      (cpu_addr_map[va] == untrusted_addr_map[va]));
      ensures (forall (va : vaddr_t) :: 
                  (cpu_enclave_id == tap_null_enc_id) ==> 
                      tap_addr_perm_eq(cpu_addr_valid[va], untrusted_addr_valid[va]));
      ensures (forall (va : vaddr_t) :: 
                  (cpu_enclave_id != tap_null_enc_id) ==> 
                      (cpu_addr_map[va] == (tap_enclave_metadata_addr_map[cpu_enclave_id])[va]));
      ensures (forall (va : vaddr_t) :: 
                  (cpu_enclave_id != tap_null_enc_id) ==> 
                      tap_addr_perm_eq(cpu_addr_valid[va], (tap_enclave_metadata_addr_valid[cpu_enclave_id])[va]));
      modifies untrusted_addr_valid;
      modifies untrusted_addr_map;
      modifies untrusted_regs;
      modifies untrusted_pc;
      modifies tap_enclave_metadata_valid;
      modifies tap_enclave_metadata_addr_map;
      modifies tap_enclave_metadata_addr_valid;
      modifies tap_enclave_metadata_addr_excl;
      modifies tap_enclave_metadata_entrypoint;
      modifies tap_enclave_metadata_pc;
      modifies tap_enclave_metadata_regs;
      modifies tap_enclave_metadata_paused;
      modifies tap_enclave_metadata_cache_conflict;
      modifies cpu_enclave_id;
      modifies cpu_addr_map;
      modifies cpu_addr_valid;
      modifies cpu_pc;
      modifies cpu_regs;
      modifies cpu_mem;
      modifies cpu_owner_map;
      modifies cache_valid_map;
      modifies cache_tag_map;
  {
      var status            : enclave_op_result_t;
      var r_eid             : tap_enclave_id_t;
      var r_addr_valid      : addr_valid_t;
      var r_addr_map        : addr_map_t;
      var r_addr_excl       : excl_vaddr_t;
      var r_excl_map        : excl_map_t;
      var r_container_valid : container_valid_t;
      var r_container_data  : container_data_t;
      var r_entrypoint      : vaddr_t;
      var r_vaddr           : vaddr_t;
      var r_paddr           : wap_addr_t;
      var r_word            : word_t;
      var r_valid           : addr_perm_t;
      var r_excp            : exception_t;
      var repl_way          : cache_way_index_t;
      var done              : boolean;
      var hit               : boolean;

      
      call initialize_tap();
      current_mode = mode_untrusted;
      // and loop will run for a few iterations.
      done = false;



      while (!done)
          // CPU invariants.
          invariant (done ==> (cpu_enclave_id == tap_null_enc_id));
          // current pc invariants
          invariant (tap_addr_perm_x(cpu_addr_valid[cpu_pc]));
          invariant (tap_addr_perm_x(untrusted_addr_valid[untrusted_pc]));
          invariant (cpu_owner_map[cpu_addr_map[cpu_pc]] == cpu_enclave_id);
          invariant (valid_enclave_id(cpu_enclave_id) || cpu_enclave_id == tap_null_enc_id);
          invariant (valid_enclave_id(cpu_enclave_id)) ==> ((tap_enclave_metadata_addr_excl[cpu_enclave_id])[cpu_pc]);
          //// OS invariants.
          invariant (valid_enclave_id(cpu_enclave_id)) ==> (tap_addr_perm_x(untrusted_addr_valid[untrusted_pc]));
          invariant (valid_enclave_id(cpu_enclave_id)) ==> (cpu_owner_map[untrusted_addr_map[untrusted_pc]] == tap_null_enc_id);
          // CPU/enclave invariants.
          invariant (valid_enclave_id(cpu_enclave_id)==> tap_enclave_metadata_valid[cpu_enclave_id]);
          invariant (cpu_enclave_id != tap_blocked_enc_id);
          // enclave invariants.
          invariant (forall (e : tap_enclave_id_t) ::
                      !valid_enclave_id(e) ==> !tap_enclave_metadata_valid[e]);
          invariant (valid_enclave_id(cpu_enclave_id)) ==> 
                      tap_addr_perm_x((tap_enclave_metadata_addr_valid[cpu_enclave_id])[cpu_pc]);
          invariant (valid_enclave_id(cpu_enclave_id)) ==> 
                      cpu_owner_map[(tap_enclave_metadata_addr_map[cpu_enclave_id])[cpu_pc]] == cpu_enclave_id;
          invariant (valid_enclave_id(cpu_enclave_id)) ==>
                      tap_addr_perm_x(
                          (tap_enclave_metadata_addr_valid[cpu_enclave_id])[tap_enclave_metadata_entrypoint[cpu_enclave_id]]);
          invariant (valid_enclave_id(cpu_enclave_id)) ==>
                      cpu_owner_map[(tap_enclave_metadata_addr_map[cpu_enclave_id])[tap_enclave_metadata_entrypoint[cpu_enclave_id]]] == cpu_enclave_id;
          invariant (forall (e : tap_enclave_id_t) ::
                      tap_enclave_metadata_valid[e] ==> 
                          tap_addr_perm_x((tap_enclave_metadata_addr_valid[e])[tap_enclave_metadata_pc[e]]));
          invariant (forall (e : tap_enclave_id_t) ::
              tap_enclave_metadata_valid[e] ==>
                tap_addr_perm_x((tap_enclave_metadata_addr_valid[e])[tap_enclave_metadata_entrypoint[e]]));

          invariant (forall (e : tap_enclave_id_t, v : vaddr_t) ::
                      (tap_enclave_metadata_valid[e] && (tap_enclave_metadata_addr_excl[e])[v]) ==> 
                              tap_addr_perm_v((tap_enclave_metadata_addr_valid[e])[v]));
          invariant (forall (e : tap_enclave_id_t, v : vaddr_t) ::
                      (tap_enclave_metadata_valid[e] && (tap_enclave_metadata_addr_excl[e])[v]) ==> 
                              (cpu_owner_map[(tap_enclave_metadata_addr_map[e])[v]] == e));
          invariant (forall (e : tap_enclave_id_t) ::
                      tap_enclave_metadata_valid[e] ==> 
                          (tap_enclave_metadata_addr_excl[e])[tap_enclave_metadata_pc[e]]);
          invariant (forall (e : tap_enclave_id_t) ::
                      tap_enclave_metadata_valid[e] ==> 
                          (tap_enclave_metadata_addr_excl[e])[tap_enclave_metadata_entrypoint[e]]);
          invariant (forall (e : tap_enclave_id_t) ::
                      tap_enclave_metadata_valid[e] ==> 
                          cpu_owner_map[(tap_enclave_metadata_addr_map[e])[tap_enclave_metadata_pc[e]]] == e);
          invariant (forall (e : tap_enclave_id_t) ::
                      tap_enclave_metadata_valid[e] ==> 
                          cpu_owner_map[(tap_enclave_metadata_addr_map[e])[tap_enclave_metadata_entrypoint[e]]] == e);
          // CPU/Enclave address map invariants.
          invariant (forall (va : vaddr_t) :: 
                      (cpu_enclave_id == tap_null_enc_id) ==> 
                          (cpu_addr_map[va] == untrusted_addr_map[va]));
          invariant (forall (va : vaddr_t) :: 
                      (cpu_enclave_id == tap_null_enc_id) ==> 
                          tap_addr_perm_eq(cpu_addr_valid[va], untrusted_addr_valid[va]));
          invariant (forall (va : vaddr_t) :: 
                      (cpu_enclave_id != tap_null_enc_id) ==> 
                          (cpu_addr_map[va] == (tap_enclave_metadata_addr_map[cpu_enclave_id])[va]));
          invariant (forall (va : vaddr_t) :: 
                      (cpu_enclave_id != tap_null_enc_id) ==> 
                          tap_addr_perm_eq(cpu_addr_valid[va], (tap_enclave_metadata_addr_valid[cpu_enclave_id])[va]));
          invariant  (forall (pa : wap_addr_t, e : tap_enclave_id_t) ::
                      (valid_enclave_id(e) && !tap_enclave_metadata_valid[e]) ==> 
                          (cpu_owner_map[pa] != e));
     {
          havoc r_eid;
          if (*) {
              havoc r_addr_valid;
              havoc r_addr_map;
              havoc r_excl_map;
              havoc r_container_valid;
              havoc r_container_data;
              havoc r_entrypoint;
              assume !r_excl_map[cpu_addr_map[cpu_pc]];
              call InitOSMem(r_container_valid, r_container_data);
              call (status) = launch(r_eid, r_addr_valid, r_addr_map, r_addr_excl, r_excl_map, r_entrypoint);
          } else {
            if (*) {
              call (status) = enter(r_eid);
            } else {
              if (*) {
                call (status) = exit();
              } else {
                if (*) {
                  call (status) = resume(r_eid);
                } else {
                  if (*) {
                    call (status) = pause();
                  } else {
                    if (*) {
                      call (status) = destroy(r_eid);
                    } else {
                      if (*) {
                        havoc r_vaddr;
                        havoc r_word;
                        havoc repl_way;
                        assume valid_cache_way_index(repl_way);
                        call (r_excp, hit) = store_va(r_vaddr, r_word, repl_way);
                      } else {
                        if (*) {
                          call havoc_cpu_pc();
                          call havoc_cpu_regs();
                          assume (tap_addr_perm_x(cpu_addr_valid[cpu_pc]));
                          assume (cpu_enclave_id != tap_null_enc_id) ==> 
                            ((tap_enclave_metadata_addr_excl[cpu_enclave_id])[cpu_pc]);
                          assume (cpu_owner_map[cpu_addr_map[cpu_pc]] == cpu_enclave_id);
                        } else {
                          if (*) {
                            if (cpu_enclave_id == tap_null_enc_id) {
                            havoc r_valid;
                            havoc r_vaddr;
                            havoc r_paddr;
                            assume r_vaddr != cpu_pc && r_vaddr != untrusted_pc;
                            call set_addr_map(r_vaddr, r_paddr, r_valid);
                            }
                          } else {
                            if (cpu_enclave_id == tap_null_enc_id) {
                              done = true;
                              assert cpu_enclave_id == tap_null_enc_id;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
      }
  }

  procedure [noinline] InitOSMem(container_valid : container_valid_t, container_data : container_data_t)
      ensures (forall (p : wap_addr_t) ::
                      if (cpu_owner_map[p] == tap_null_enc_id && container_valid[p])
                          then cpu_mem[p] == container_data[p]
                          else cpu_mem[p] == old(cpu_mem)[p]);
  {}

  procedure [noinline] HavocOSMem(excl_map : excl_map_t)
      ensures (forall (p : wap_addr_t) ::
                      (cpu_owner_map[p] != tap_null_enc_id || !excl_map[p])
                          ==> (cpu_mem[p] == old(cpu_mem)[p]));
  {}

  procedure InitUntrustedState(_untrusted_addr_valid: addr_valid_t, _untrusted_addr_map: addr_map_t, _untrusted_pc: vaddr_t)
      modifies untrusted_addr_valid;
      modifies untrusted_addr_map;
      modifies untrusted_pc;
  {
      untrusted_addr_valid = _untrusted_addr_valid;
      untrusted_addr_map = _untrusted_addr_map;
      untrusted_pc = _untrusted_pc;
  }
    

  //--------------------------------------------------------------------------//
  // Utility functions for measurement theorem.                               //
  //--------------------------------------------------------------------------//
  procedure [inline] MeasurementEnclaveComputation(iter : integer)
      returns (vaddr : vaddr_t, data : word_t)

      requires (tap_enclave_metadata_valid[cpu_enclave_id]);
      requires tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
      requires cpu_owner_map[cpu_addr_map[cpu_pc]] == cpu_enclave_id;

      modifies cpu_regs;
      modifies cpu_pc;
      modifies cpu_mem;
      modifies cpu_addr_valid;
      modifies cache_valid_map, cache_tag_map;
  {
      var r0, r1  : word_t;
      var rd      : regindex_t;
      var eid     : tap_enclave_id_t;
      var pc_pa   : wap_addr_t;
      var pc_op   : word_t;
      var l_vaddr : vaddr_t;
      var l_data  : word_t;
      var s_vaddr : vaddr_t;
      var s_data  : word_t;
      var excp    : exception_t;
      var hit     : boolean;
      var way     : cache_way_index_t;

      eid = cpu_enclave_id;
      pc_pa = cpu_addr_map[cpu_pc];
      assert (tap_enclave_metadata_addr_excl[eid])[cpu_pc];
      assert cpu_owner_map[pc_pa] == eid;
      havoc way; 
      assume valid_cache_way_index(way);
      call (pc_op, excp, hit) = fetch_va(cpu_pc, way);
      assert excp == excp_none;

      // two register sources.
      r0 = cpu_regs[uf_cpu_r0_index(pc_op)];
      r1 = cpu_regs[uf_cpu_r1_index(pc_op)];

      // load address and value.
      l_vaddr = uf_mem_load_vaddr(cpu_pc, pc_op, r0, r1);
      assume tap_addr_perm_r(cpu_addr_valid[l_vaddr]);
      if((tap_enclave_metadata_addr_excl[eid])[l_vaddr]) {
          assert cpu_owner_map[cpu_addr_map[l_vaddr]] == eid;
          havoc way; 
          assume valid_cache_way_index(way);
          call (l_data, excp, hit) = load_va(l_vaddr, way);
      } else {
          l_data = uf_load_data(l_vaddr, iter);
          excp = excp_none;
          hit = false;
      }

      // get data to store to mem.
      s_vaddr = uf_mem_store_vaddr(cpu_pc, pc_op, l_data, r0, r1);
      s_data = uf_mem_store_data(cpu_pc, pc_op, l_data, r0, r1);
      assume tap_addr_perm_w(cpu_addr_valid[s_vaddr]);
      // update mem if we are writing to private memory.
      if ((tap_enclave_metadata_addr_excl[eid])[s_vaddr]) {
          assert cpu_owner_map[cpu_addr_map[s_vaddr]] == eid;
          havoc way; 
          assume valid_cache_way_index(way);
          call (excp, hit) = store_va(s_vaddr, s_data, way);
          assert excp == excp_none;
      }
      // if we're writing to shared memory, there's no point because
      // we can't expect the OS to "remember" what we wrote anyway.
      // but we do check that both enclaves write the same data to 
      // the same vaddr.
      vaddr = s_vaddr;
      data = s_data;

      // update pc.
      call set_cpu_pc(uf_cpu_pc(cpu_pc, pc_op, l_data, r0, r1));
      assume tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
      assume (tap_enclave_metadata_addr_excl[eid])[cpu_pc];
      assert cpu_owner_map[cpu_addr_map[cpu_pc]] == eid;
      // update regs.
      rd = uf_cpu_r2_index(pc_op);
      call update_cpu_regs(rd, uf_cpu_result(cpu_pc, pc_op, l_data, r0, r1));
  }
                        
  define is_measurement_untrusted_op(op : tap_proof_op_t) : boolean
  = op == tap_proof_op_resume || op == tap_proof_op_enter;


  define is_measurement_enclave_op(op : tap_proof_op_t) : boolean
  = op == tap_proof_op_compute    ||
    op == tap_proof_op_pause      ||
    op == tap_proof_op_exit;


  procedure [inline] MeasurementUntrustedOp(
      /* operation */ op   : tap_proof_op_t, 
      /* enclave   */ eid  : tap_enclave_id_t,
      /* args      */ regs : regs_t
  ) 
    returns (status : enclave_op_result_t, current_mode : mode_t)
    ensures (current_mode == mode_untrusted ==> cpu_enclave_id == tap_null_enc_id);
    modifies untrusted_addr_valid;
    modifies untrusted_addr_map;
    modifies untrusted_regs;
    modifies untrusted_pc;
    modifies tap_enclave_metadata_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_entrypoint;
    modifies tap_enclave_metadata_pc;
    modifies tap_enclave_metadata_regs;
    modifies tap_enclave_metadata_paused;
    modifies tap_enclave_metadata_cache_conflict;
    modifies cpu_regs;
    modifies cpu_enclave_id;
    modifies cpu_addr_map;
    modifies cpu_addr_valid;
    modifies cpu_pc;
  {
      assert (is_measurement_untrusted_op(op));
      status = enclave_op_success;
      if (op == tap_proof_op_enter) {
          call set_cpu_regs(regs);
          assert(cpu_enclave_id == tap_null_enc_id);
          call (status) = enter(eid);
          assert status == enclave_op_success;
          current_mode = mode_enclave;
      } else {
          if (op == tap_proof_op_resume) {
            call (status) = resume(eid);
            if (status == enclave_op_success) {
                current_mode = mode_enclave;
            } else {
                current_mode = mode_untrusted;
            }
          }
      }
  }

  procedure [inline] MeasurementEnclaveOp(
      /* operation */ op   : tap_proof_op_t,
      /* iteration */ iter : integer
  ) 
    returns (status : enclave_op_result_t, current_mode : mode_t, vaddr : vaddr_t, word : word_t)
    modifies untrusted_addr_valid;
    modifies untrusted_addr_map;
    modifies untrusted_regs;
    modifies untrusted_pc;
    modifies tap_enclave_metadata_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_entrypoint;
    modifies tap_enclave_metadata_pc;
    modifies tap_enclave_metadata_regs;
    modifies tap_enclave_metadata_paused;
    modifies tap_enclave_metadata_cache_conflict;
    modifies cpu_regs;
    modifies cpu_pc;
    modifies cpu_mem;
    modifies cpu_addr_valid;
    modifies cpu_enclave_id;
    modifies cpu_addr_map;
    modifies cache_valid_map, cache_tag_map;
  {
      assert (is_measurement_enclave_op(op));
      vaddr = k0_vaddr_t;
      word  = k0_word_t;
      case 
        (op == tap_proof_op_compute) : {
          call (vaddr, word) = MeasurementEnclaveComputation(iter);
          status = enclave_op_success;
          current_mode = mode_enclave;
        } 
        (op == tap_proof_op_exit) : {
          call (status) = exit();
          current_mode = mode_untrusted;
        } 
        (op == tap_proof_op_pause) : {
          call (status) = pause();
          current_mode = mode_untrusted;
        }
      esac
      assert status == enclave_op_success;
  }

  //
  // Utility functions for integrity proofs
  //
  // The computation performed by the enclave.
  procedure [inline] EnclaveComputation(iter : integer)
      returns (vaddr : vaddr_t, paddr : wap_addr_t, data : word_t)

      requires (tap_enclave_metadata_valid[cpu_enclave_id]);
      requires tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
      requires cpu_owner_map[cpu_addr_map[cpu_pc]] == cpu_enclave_id;

      modifies cpu_pc;
      modifies cpu_regs;
      modifies cpu_mem;
      modifies cpu_addr_valid;
      modifies cache_valid_map, cache_tag_map;
  {
      var r0, r1  : word_t;
      var rd      : regindex_t;
      var eid     : tap_enclave_id_t;
      var pc_pa   : wap_addr_t;
      var pc_op   : word_t;
      var l_vaddr : vaddr_t;
      var l_data  : word_t;
      var s_vaddr : vaddr_t;
      var s_data  : word_t;
      var excp    : exception_t;
      var hit     : boolean;
      var way     : cache_way_index_t;

      eid = cpu_enclave_id;
      pc_pa = cpu_addr_map[cpu_pc];
      assert tap_enclave_metadata_addr_excl[eid][cpu_pc];
      assert tap_addr_perm_x(cpu_addr_valid[cpu_pc]);

      havoc way; 
      assume valid_cache_way_index(way);

      call (pc_op, excp, hit) = fetch_va(cpu_pc, way);
      assert excp == excp_none;

      // two register sources.
      r0 = cpu_regs[uf_cpu_r0_index(pc_op)];
      r1 = cpu_regs[uf_cpu_r1_index(pc_op)];

      // load address and value.
      l_vaddr = ap_types.uf_mem_load_vaddr(cpu_pc, pc_op, r0, r1);
      assume tap_addr_perm_r(cpu_addr_valid[l_vaddr]);
      if (tap_enclave_metadata_addr_excl[eid][l_vaddr]) {
          assert cpu_owner_map[cpu_addr_map[l_vaddr]] == eid;

          havoc way; 
          assume valid_cache_way_index(way);

          call (l_data, excp, hit) = load_va(l_vaddr, way);
          assert excp == excp_none;
      } else {
          hit = false;
          excp = excp_none;
          l_data = uf_load_data(l_vaddr, iter);
      }

      // get data to store to mem.
      s_vaddr = uf_mem_store_vaddr(cpu_pc, pc_op, l_data, r0, r1);
      s_data = ap_types.uf_mem_store_data(cpu_pc, pc_op, l_data, r0, r1);
      vaddr = s_vaddr;
      paddr = cpu_addr_map[s_vaddr];
      data = s_data;

      // update mem.
      assume tap_addr_perm_w(cpu_addr_valid[s_vaddr]);
      if (tap_enclave_metadata_addr_excl[eid][s_vaddr]) {
          assert (cpu_owner_map[cpu_addr_map[s_vaddr]] == eid);

          havoc way; 
          assume valid_cache_way_index(way);

          call (excp, hit) = store_va(s_vaddr, s_data, way);
          assert excp == excp_none;
      }

      // update pc.
      call set_cpu_pc(uf_cpu_pc(cpu_pc, pc_op, l_data, r0, r1));
      assume tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
      assume tap_enclave_metadata_addr_excl[eid][cpu_pc];
      assert cpu_owner_map[cpu_addr_map[cpu_pc]] == eid;
      // update regs.
      rd = uf_cpu_r2_index(pc_op);
      call update_cpu_regs(rd, uf_cpu_result(cpu_pc, pc_op, l_data, r0, r1));
  }

  procedure [inline] IntegrityAdversarialStep(
      /* mode       */ mode       : mode_t,
      /* EuT        */ eid        : tap_enclave_id_t,
      /* Adversary  */ r_eid      : tap_enclave_id_t,
      /* args       */ r_regs     : regs_t,
      /* operation  */ op         : tap_proof_op_t
  )

      returns (next_mode : mode_t, enclave_dead : boolean)
      modifies untrusted_addr_valid;
      modifies untrusted_addr_map;
      modifies untrusted_regs;
      modifies untrusted_pc;
      modifies tap_enclave_metadata_valid;
      modifies tap_enclave_metadata_addr_map;
      modifies tap_enclave_metadata_addr_valid;
      modifies tap_enclave_metadata_addr_excl;
      modifies tap_enclave_metadata_entrypoint;
      modifies tap_enclave_metadata_pc;
      modifies tap_enclave_metadata_regs;
      modifies tap_enclave_metadata_paused;
      modifies tap_enclave_metadata_cache_conflict;
      modifies cpu_pc;
      modifies cpu_mem;
      modifies cpu_regs;
      modifies cpu_addr_valid;
      modifies cpu_addr_map;
      modifies cpu_owner_map;
      modifies cpu_enclave_id;
      modifies cache_valid_map, cache_tag_map;
  {
      var status            : enclave_op_result_t;
      var r_addr_valid      : addr_valid_t;
      var r_addr_map        : addr_map_t;
      var r_excl_vaddr      : excl_vaddr_t;
      var r_excl_map        : excl_map_t;
      var r_container_valid : container_valid_t;
      var r_container_data  : container_data_t;
      var r_entrypoint      : vaddr_t;
      var r_vaddr           : vaddr_t;
      var r_valid           : addr_perm_t;
      var r_excp            : exception_t;
      var r_paddr           : wap_addr_t;
      var r_word            : word_t;
      var r_bmap            : excl_map_t;
      var hit               : boolean;
      var way               : cache_way_index_t;

      // the "default" value which may be overwritten by enter/resume
      next_mode = mode;
      // the "default" value which may be overwritten by destroy.
      enclave_dead = false;

      case 
      (op == tap_proof_op_launch) : {            
          // launch
          call InitOSMem(r_container_valid, r_container_data);
          call (status) = launch(r_eid, r_addr_valid, r_addr_map, 
                                r_excl_vaddr, r_excl_map, r_entrypoint);
          assert (r_eid == eid) ==> (status != enclave_op_success);
      } 
      (op == tap_proof_op_enter) : {      
          // enter
          call set_cpu_regs(r_regs);
          call (status) = enter(r_eid);
          // mode == mode_enclave means we are in trace_2.
          assert (mode == mode_enclave ==> status == enclave_op_success);
          if (status == enclave_op_success && r_eid == eid) { 
              next_mode = mode_enclave; 
          }
          assert ((status == enclave_op_success && r_eid == eid)
                  ==> next_mode == mode_enclave);
      } 
      (op == tap_proof_op_resume) : {     
          // resume
          call (status) = resume(r_eid);
          // mode == mode_enclave means we are in trace_2.
          assert (mode == mode_enclave ==> status == enclave_op_success);
          if (status == enclave_op_success && r_eid == eid) { 
              next_mode = mode_enclave; 
          }
          assert ((status == enclave_op_success && r_eid == eid)
                  ==> next_mode == mode_enclave);
      } 
      (op == tap_proof_op_exit) : {       
          // exit
          call (status) = exit();
      } 
      (op == tap_proof_op_pause) : {      
          // pause.
          call (status) = pause();
      } 
      (op == tap_proof_op_destroy) : {    
          // destroy.
          call (status) = destroy(r_eid);
          if (r_eid == eid && status == enclave_op_success) {
              enclave_dead = true;
          }
          assert(mode == mode_untrusted ==> next_mode != mode_enclave);
      } 
      (op == tap_proof_op_release) : {
          call (status) = release_blocked_memory(r_bmap);
      } 
      (op == tap_proof_op_block) : {
          call (status) = block_memory_region(r_bmap);
      } 
      // (op == tap_proof_op_compute) : {    
      default : {    
          // some adversarial computation
          if (*) {
              havoc r_vaddr;
              havoc r_word;
              havoc way; assume valid_cache_way_index(way);
              call (r_excp, hit) = store_va(r_vaddr, r_word, way);
          } else {
              if (*) {
                  call havoc_cpu_pc();
                  call havoc_cpu_regs();
              } else {
                  if (*) {
                      // update "page" table map.
                      havoc r_vaddr;
                      havoc r_paddr;
                      havoc r_valid;
                      call update_cpu_addr_valid(r_vaddr, r_valid);
                      call update_cpu_addr_map(r_vaddr, r_paddr);
                  } else {
                      if (*) {
                          havoc r_vaddr;
                          havoc r_paddr;
                          havoc r_valid;
                          call (status) = set_enclave_addr_map(r_eid, r_vaddr, r_valid, r_paddr);
                      }
                  }
              }
          }
      }
      esac

      assert (op != tap_proof_op_enter && op != tap_proof_op_resume)
        ==> next_mode == mode;
  } 

  define tap_proof_op_valid_in_enclave(o : tap_proof_op_t) : boolean
  = (o == tap_proof_op_compute) ||
    (o == tap_proof_op_pause)   ||
    (o == tap_proof_op_exit);

  procedure [inline] IntegrityEnclaveStep(
      /* what operation?  */  op : tap_proof_op_t, 
      /* which iteration? */  iter : integer
  )
      returns (next_mode : mode_t, vaddr : vaddr_t, paddr : wap_addr_t, data : word_t)
      ensures (op == tap_proof_op_compute ==> next_mode == mode_enclave);
      ensures (op != tap_proof_op_compute ==> next_mode == mode_untrusted);
      modifies tap_enclave_metadata_valid;
      modifies tap_enclave_metadata_addr_map;
      modifies tap_enclave_metadata_addr_valid;
      modifies tap_enclave_metadata_pc;
      modifies tap_enclave_metadata_regs;
      modifies tap_enclave_metadata_paused;
      modifies cpu_pc;
      modifies cpu_regs;
      modifies cpu_mem;
      modifies cpu_addr_valid;
      modifies cpu_enclave_id;
      modifies cpu_addr_map;
      modifies cpu_regs;
      modifies cache_valid_map, cache_tag_map;
  {
      var status : enclave_op_result_t;
      assert tap_proof_op_valid_in_enclave(op);

      vaddr = k0_vaddr_t;
      paddr = k0_wap_addr_t;
      data = k0_word_t;

      // in enclave-mode:
      case
      (op == tap_proof_op_pause) : {
          call (status) = pause();
          assert status == enclave_op_success;
          next_mode = mode_untrusted;
      }
      (op == tap_proof_op_exit) : {
          call (status) = exit();
          assert status == enclave_op_success;
          next_mode = mode_untrusted;
      }
      // (op == tap_proof_op_compute) : {
      default: {
          call (vaddr, paddr, data) = EnclaveComputation(iter);
          next_mode = mode_enclave;
      } 
      esac
  }



  //
  // Utilities for confidentiality proofs
  //
  procedure [inline] MemObserverComputation(
      /* next PC value.           */  r_pc : vaddr_t,
      /* registers to read/write. */  r_read : regindex_t, r_write : regindex_t, r_data: word_t,
      /* mem. to read/write.      */  l_vaddr: vaddr_t, s_vaddr: vaddr_t, s_data : word_t,
      /* "pt" entry to read       */  r_pt_eid : tap_enclave_id_t, r_pt_va : vaddr_t,
      /* "pt" entry to change.    */  pt_eid : tap_enclave_id_t, pt_vaddr: vaddr_t, 
      /* "pt" entry to change.    */  pt_valid: addr_perm_t, pt_paddr: wap_addr_t)
      returns (observation : word_t)
      requires valid_regindex(r_read);
      requires valid_regindex(r_write);

      modifies untrusted_addr_valid;
      modifies tap_enclave_metadata_addr_valid;
      modifies tap_enclave_metadata_addr_map;
      modifies untrusted_addr_map;
      modifies cpu_mem;
      modifies cpu_addr_valid;
      modifies cpu_addr_map;
      modifies cpu_regs;
      modifies cpu_pc;
      modifies cache_valid_map, cache_tag_map;
  {
      var excp         : exception_t;
      var l_word       : word_t;
      var r_word       : word_t;
      var hit_1, hit_2 : boolean;
      var valid        : addr_perm_t;
      var paddr        : wap_addr_t;
      var status       : enclave_op_result_t;
      var l_way, s_way : cache_way_index_t;

      assume valid_cache_way_index(l_way);
      assume valid_cache_way_index(s_way);

      call set_cpu_pc(r_pc);
      call update_cpu_regs(r_write, r_data);
      // store
      call (excp, hit_1) = store_va(s_vaddr, s_data, s_way);
      // load
      call (l_word, excp, hit_2) = load_va(l_vaddr, l_way);
      r_word = cpu_regs[r_read];
      observation = uf_observation_mem(cpu_pc, l_word, r_word);

      if (pt_eid == tap_null_enc_id) {
          call set_addr_map(pt_vaddr, pt_paddr, pt_valid);
      } else {
          call (status) = set_enclave_addr_map(pt_eid, pt_vaddr, pt_valid, pt_paddr);
      }
  }


  procedure [inline] CacheObserverComputation(
      /* next PC value.           */  r_pc : vaddr_t,
      /* registers to read/write. */  r_read : regindex_t, r_write : regindex_t, r_data: word_t,
      /* mem. to read/write.      */  l_vaddr: vaddr_t, s_vaddr: vaddr_t, s_data : word_t,
      /* "pt" entry to read       */  r_pt_eid : tap_enclave_id_t, r_pt_va : vaddr_t,
      /* "pt" entry to change.    */  pt_eid : tap_enclave_id_t, pt_vaddr: vaddr_t, 
      /* "pt" entry to change.    */  pt_valid: addr_perm_t, pt_paddr: wap_addr_t,
      /* ways to change.          */  l_way, s_way : cache_way_index_t)
      returns (observation : word_t, hit_1 : boolean, hit_2 : boolean,
               excp_1 : exception_t, excp_2 : exception_t)
      requires valid_regindex(r_read);
      requires valid_regindex(r_write);
      requires valid_cache_way_index(s_way);
      requires valid_cache_way_index(l_way);

      ensures ((!tap_addr_perm_w(old(cpu_addr_valid)[s_vaddr]) ||
                (cpu_owner_map[old(cpu_addr_map)[s_vaddr]] != tap_null_enc_id && cpu_owner_map[old(cpu_addr_map)[s_vaddr]] != cpu_enclave_id)) &&
               (!tap_addr_perm_r(old(cpu_addr_valid)[l_vaddr]) ||
                (cpu_owner_map[old(cpu_addr_map)[l_vaddr]] != tap_null_enc_id && cpu_owner_map[old(cpu_addr_map)[l_vaddr]] != cpu_enclave_id)))
               ==> (observation == uf_observation_cache(false, false));

      ensures (forall (p : wap_addr_t, w : cache_way_index_t) ::
                 ((paddr2set(p) != paddr2set(old(cpu_addr_map)[s_vaddr]) || w != s_way) && 
                  (paddr2set(p) != paddr2set(old(cpu_addr_map)[l_vaddr]) || w != l_way))
                    ==> ((cache_valid_map[paddr2set(p), w] == old(cache_valid_map)[paddr2set(p), w]) &&
                         (cache_tag_map[paddr2set(p), w] == old(cache_tag_map)[paddr2set(p), w])));
      ensures (cpu_cache_enabled) ==>
              (forall (p : wap_addr_t, w : cache_way_index_t) ::
                      ((paddr2set(p) == paddr2set(old(cpu_addr_map)[s_vaddr]) && w == s_way) &&
                      (paddr2set(old(cpu_addr_map)[s_vaddr]) != paddr2set(old(cpu_addr_map)[l_vaddr]) || s_way != l_way) &&
                      (excp_1 != excp_none || hit_1))
                      ==> 
                          (cache_valid_map[paddr2set(p), w] == old(cache_valid_map)[paddr2set(p), w] &&
                           cache_tag_map[paddr2set(p), w] == old(cache_tag_map)[paddr2set(p), w]));

      ensures (cpu_cache_enabled) ==>
              (forall (p : wap_addr_t, w : cache_way_index_t) ::
                      ((paddr2set(p) == paddr2set(old(cpu_addr_map)[s_vaddr]) && w == s_way) &&
                      (paddr2set(old(cpu_addr_map)[s_vaddr]) != paddr2set(old(cpu_addr_map)[l_vaddr]) || s_way != l_way) &&
                      (excp_1 == excp_none && !hit_1))
                      ==> 
                          (cache_valid_map[paddr2set(p), w] == true &&
                           cache_tag_map[paddr2set(p), w] == paddr2tag(old(cpu_addr_map)[s_vaddr])));

      ensures (cpu_cache_enabled) ==>
                (forall (p : wap_addr_t, w : cache_way_index_t) ::
                      ((paddr2set(p) == paddr2set(old(cpu_addr_map)[l_vaddr]) && w == l_way) &&
                      (paddr2set(old(cpu_addr_map)[s_vaddr]) != paddr2set(old(cpu_addr_map)[l_vaddr]) || s_way != l_way) &&
                      (excp_2 != excp_none || hit_2))
                      ==> 
                          (cache_valid_map[paddr2set(p), w] == old(cache_valid_map)[paddr2set(p), w] &&
                           cache_tag_map[paddr2set(p), w] == old(cache_tag_map)[paddr2set(p), w]));

      ensures (cpu_cache_enabled) ==>
                (forall (p : wap_addr_t, w : cache_way_index_t) ::
                      ((paddr2set(p) == paddr2set(old(cpu_addr_map)[l_vaddr]) && w == l_way) &&
                      (paddr2set(old(cpu_addr_map)[s_vaddr]) != paddr2set(old(cpu_addr_map)[l_vaddr]) || s_way != l_way) &&
                      (excp_2 == excp_none && !hit_2))
                      ==> 
                          (cache_valid_map[paddr2set(p), w] == true &&
                           cache_tag_map[paddr2set(p), w] == paddr2tag(old(cpu_addr_map)[l_vaddr])));

      // Invariants for when s_vaddr and p_addr map to the same location in the cache
      ensures (cpu_cache_enabled) ==>
                (forall (p : wap_addr_t, w : cache_way_index_t) ::
                  ((paddr2set(p) == paddr2set(old(cpu_addr_map)[s_vaddr]) && w == s_way) &&
                   (paddr2set(old(cpu_addr_map)[s_vaddr]) == paddr2set(old(cpu_addr_map)[l_vaddr]) && s_way == l_way) &&
                    ((hit_1 && hit_2) || 
                     (excp_2 != excp_none && hit_1 && !hit_2) ||
                     (excp_1 != excp_none && !hit_1 && hit_2) ||
                     (excp_1 != excp_none && excp_2 != excp_none)))
                  ==> (cache_valid_map[paddr2set(p), w] == old(cache_valid_map)[paddr2set(p), w] && 
                       cache_tag_map[paddr2set(p), w] == old(cache_tag_map)[paddr2set(p), w]));

      ensures (cpu_cache_enabled) ==> 
                (forall (p : wap_addr_t, w : cache_way_index_t) ::
                  ((paddr2set(p) == paddr2set(old(cpu_addr_map)[s_vaddr]) && w == s_way) &&
                   (paddr2set(old(cpu_addr_map)[s_vaddr]) == paddr2set(old(cpu_addr_map)[l_vaddr]) && s_way == l_way) &&
                    ((excp_2 == excp_none && hit_1 && !hit_2) ||
                     (excp_1 != excp_none && excp_2 == excp_none && !hit_1 && !hit_2) ||
                     (excp_1 == excp_none && excp_2 == excp_none && !hit_1 && !hit_2)))
                  ==> (cache_valid_map[paddr2set(p), w] == true &&
                       cache_tag_map[paddr2set(p), w] == paddr2tag(old(cpu_addr_map)[l_vaddr])));

      ensures (cpu_cache_enabled) ==> 
                (forall (p : wap_addr_t, w : cache_way_index_t) ::
                  ((paddr2set(p) == paddr2set(old(cpu_addr_map)[s_vaddr]) && w == s_way) &&
                   (paddr2set(old(cpu_addr_map)[s_vaddr]) == paddr2set(old(cpu_addr_map)[l_vaddr]) && s_way == l_way) &&
                     ((excp_1 == excp_none && !hit_1 && hit_2) ||
                      (excp_1 == excp_none && excp_2 != excp_none && !hit_1 && !hit_2)))
                  ==> (cache_valid_map[paddr2set(p), w] == true &&
                       cache_tag_map[paddr2set(p), w] == paddr2tag(old(cpu_addr_map)[s_vaddr])));

    
      ensures (s_vaddr != l_vaddr || s_way != l_way)
                ==> ((cache_valid_map[paddr2set(old(cpu_addr_map)[s_vaddr]), s_way] == old(cache_valid_map)[paddr2set(old(cpu_addr_map)[s_vaddr]), s_way]) ||
                     (cache_valid_map[paddr2set(old(cpu_addr_map)[s_vaddr]), s_way] == true));
      ensures ((cache_valid_map[paddr2set(old(cpu_addr_map)[l_vaddr]), l_way] == old(cache_valid_map)[paddr2set(old(cpu_addr_map)[l_vaddr]), l_way]) ||
                     (cache_valid_map[paddr2set(old(cpu_addr_map)[l_vaddr]), l_way] == true));

      ensures (!cpu_cache_enabled) ==> 
                (cache_valid_map == old(cache_valid_map) && cache_tag_map == old(cache_tag_map));

      ensures (excp_1 == excp_none && cpu_cache_enabled && !hit_1 &&
               (paddr2set(old(cpu_addr_map)[s_vaddr]) != paddr2set(old(cpu_addr_map)[l_vaddr]) || s_way != l_way)) 
                ==> ((cache_valid_map[paddr2set(old(cpu_addr_map)[s_vaddr]), s_way] == true) &&
                      (cache_tag_map[paddr2set(old(cpu_addr_map)[s_vaddr]), s_way] == paddr2tag(old(cpu_addr_map)[s_vaddr])));
      
      ensures (excp_2 == excp_none && cpu_cache_enabled && !hit_2)
                ==> ((cache_valid_map[paddr2set(old(cpu_addr_map)[l_vaddr]), l_way] == true) &&
                      (cache_tag_map[paddr2set(old(cpu_addr_map)[l_vaddr]), l_way] == paddr2tag(old(cpu_addr_map)[l_vaddr])));

      

      ensures (cpu_cache_enabled && hit_1 && hit_2)
              ==> (cache_valid_map == old(cache_valid_map) && cache_tag_map == old(cache_tag_map));


      ensures (excp_1 != excp_none) ==> (hit_1 == false);
      ensures (excp_2 != excp_none) ==> (hit_2 == false);
      ensures (!cpu_cache_enabled) ==> (hit_1 == false && hit_2 == false);





   
      modifies tap_enclave_metadata_addr_valid;
      modifies tap_enclave_metadata_addr_map;
      modifies untrusted_addr_valid;
      modifies untrusted_addr_map;
      modifies cpu_mem;
      modifies cpu_pc;
      modifies cpu_regs;
      modifies cpu_addr_valid;
      modifies cpu_addr_map;
      modifies cache_valid_map, cache_tag_map;
  {
      var excp         : exception_t;
      var l_word       : word_t;
      var r_word       : word_t;
      var valid        : addr_perm_t;
      var paddr        : wap_addr_t;
      var status       : enclave_op_result_t;

      call set_cpu_pc(r_pc);
      call update_cpu_regs(r_write, r_data);
      call (excp_1, hit_1) = store_va(s_vaddr, s_data, s_way);
      call (valid, paddr) = get_enclave_addr_map(r_pt_eid, r_pt_va);
      call (l_word, excp_2, hit_2) = load_va(l_vaddr, l_way);
      r_word = cpu_regs[r_read];
      observation = uf_observation_cache(hit_1, hit_2);

      if (pt_eid == tap_null_enc_id) {
          call set_addr_map(pt_vaddr, pt_paddr, pt_valid);
      } else {
          call (status) = set_enclave_addr_map(pt_eid, pt_vaddr, pt_valid, pt_paddr);
      }
  }


  procedure [inline] PTObserverComputation(
      /* next PC value.           */  r_pc : vaddr_t,
      /* registers to read/write. */  r_read : regindex_t, r_write : regindex_t, r_data: word_t,
      /* mem. to read/write.      */  l_vaddr: vaddr_t, s_vaddr: vaddr_t, s_data : word_t,
      /* "pt" entry to read       */  r_pt_eid : tap_enclave_id_t, r_pt_va : vaddr_t,
      /* "pt" entry to change.    */  pt_eid : tap_enclave_id_t, pt_vaddr: vaddr_t, 
      /* "pt" entry to change.    */  pt_valid: addr_perm_t, pt_paddr: wap_addr_t)
      returns (observation : word_t, excp : exception_t)
      requires valid_regindex(r_read);
      requires valid_regindex(r_write);
      ensures (pt_eid == tap_null_enc_id && cpu_enclave_id == tap_null_enc_id)
                ==> ((forall (va : vaddr_t) ::
                      (va != pt_vaddr) ==>
                        (cpu_addr_valid[va] == old(untrusted_addr_valid)[va])) &&
                      (cpu_addr_valid[pt_vaddr] == pt_valid));
      ensures (pt_eid == tap_null_enc_id && cpu_enclave_id != tap_null_enc_id)
                ==> (forall (va : vaddr_t) ::
                      (va != s_vaddr)
                        ==> (cpu_addr_valid[va] == old(cpu_addr_valid)[va]));
      ensures (pt_eid != tap_null_enc_id)
                ==> (forall (va : vaddr_t) ::
                      (va != s_vaddr)
                        ==> (cpu_addr_valid[va] == old(cpu_addr_valid)[va]));
      ensures (pt_eid != tap_null_enc_id && excp == excp_none)
                ==> (cpu_addr_valid[s_vaddr] == tap_set_addr_perm_a(old(cpu_addr_valid)[s_vaddr]));
      ensures (pt_eid != tap_null_enc_id && excp != excp_none)
              ==> (cpu_addr_valid[s_vaddr] == old(cpu_addr_valid)[s_vaddr]);
      ensures (pt_eid == tap_null_enc_id && cpu_enclave_id != tap_null_enc_id  && excp == excp_none)
                ==> (cpu_addr_valid[s_vaddr] == tap_set_addr_perm_a(old(cpu_addr_valid)[s_vaddr]));
      ensures (pt_eid == tap_null_enc_id && cpu_enclave_id != tap_null_enc_id &&  excp != excp_none)
              ==> (cpu_addr_valid[s_vaddr] == old(cpu_addr_valid)[s_vaddr]);
      ensures (block_os_ev_read && (tap_enclave_metadata_addr_excl[r_pt_eid])[r_pt_va])
              ==> (observation == uf_observation_pt(k0_addr_perm_t, k0_wap_addr_t));
      ensures (cpu_enclave_id != tap_null_enc_id || !tap_enclave_metadata_valid[r_pt_eid])
              ==> (observation == uf_observation_pt(k0_addr_perm_t, k0_wap_addr_t));
      ensures (cpu_enclave_id == tap_null_enc_id && tap_enclave_metadata_valid[r_pt_eid] && (!block_os_ev_read || !((tap_enclave_metadata_addr_excl[r_pt_eid])[r_pt_va])))
              ==> (observation == uf_observation_pt(
                               (old(tap_enclave_metadata_addr_valid)[r_pt_eid])[r_pt_va],
                               (old(tap_enclave_metadata_addr_map)[r_pt_eid])[r_pt_va]));



      
      
   
      modifies untrusted_addr_valid;
      modifies tap_enclave_metadata_addr_valid;
      modifies tap_enclave_metadata_addr_map;
      modifies untrusted_addr_map;
      modifies cpu_mem;
      modifies cpu_pc;
      modifies cpu_regs;
      modifies cpu_addr_valid;
      modifies cpu_addr_map;
      modifies cache_valid_map, cache_tag_map;
  {
      var l_word       : word_t;
      var r_word       : word_t;
      var hit_1, hit_2 : boolean;
      var valid        : addr_perm_t;
      var paddr        : wap_addr_t;
      var status       : enclave_op_result_t;
      var l_way, s_way : cache_way_index_t;
      
      havoc excp;

      assume (excp != excp_none);
      assume valid_cache_way_index(l_way);
      assume valid_cache_way_index(s_way);

      // make observation.
      call (valid, paddr) = get_enclave_addr_map(r_pt_eid, r_pt_va);
      observation = uf_observation_pt(valid, paddr);

      // change state.
      call set_cpu_pc(r_pc);
      call update_cpu_regs(r_write, r_data);
      call (excp, hit_1) = store_va(s_vaddr, s_data, s_way);
      if (pt_eid == tap_null_enc_id) {
          call set_addr_map(pt_vaddr, pt_paddr, pt_valid);
      } else {
          call (status) = set_enclave_addr_map(pt_eid, pt_vaddr, pt_valid, pt_paddr);
      }
  }


  procedure [inline] ObserverStep(
      /* observer          */ observer          : observer_t,
      /* Current mode      */ mode              : mode_t,
      /* Secret Enclave    */ eid               : tap_enclave_id_t,
      /* Adversary Enclave */ r_eid             : tap_enclave_id_t,
      /* Operation.        */ op                : tap_proof_op_t,
      /* next PC value.    */ r_pc              : vaddr_t,
      /* reg to read.      */ r_read            : regindex_t,
      /* reg to write      */ r_write           : regindex_t,
      /* data to write     */ r_data            : word_t,
      /* mem. to read.     */ l_vaddr           : vaddr_t,
      /* mem to write      */ s_vaddr           : vaddr_t,
      /* data to write     */ s_data            : word_t,
      /* pt entry to read  */ r_pt_eid          : tap_enclave_id_t, 
      /* pt entry to read  */ r_pt_va           : vaddr_t,
      /* pt eid            */ pt_eid            : tap_enclave_id_t,
      /* pt vaddr          */ pt_vaddr          : vaddr_t,
      /* pt valid          */ pt_valid          : addr_perm_t,
      /* pt paddr          */ pt_paddr          : wap_addr_t,
      /* VA->PA valid      */ r_addr_valid      : addr_valid_t,
      /* VA->PA map        */ r_addr_map        : addr_map_t,
      /* VA->excl map      */ r_excl_vaddr      : excl_vaddr_t,
      /* Private Mem Map   */ r_excl_map        : excl_map_t,
      /* Container Valid   */ r_container_valid : container_valid_t,
      /* Container Data    */ r_container_data  : container_data_t,
      /* Entrypoint        */ r_entrypoint      : vaddr_t,
      /* blocked mem       */ r_bmap            : excl_map_t,
      /* ways to change.   */ l_way, s_way      : cache_way_index_t)

      returns (observation: word_t, next_mode : mode_t, enclave_dead : boolean, status : enclave_op_result_t, excp_1 : exception_t, excp_2 : exception_t, hit_1 : boolean, hit_2 : boolean)
      // PC stays reasonable.
      // Don't mess up TAP invariants.
      requires valid_regindex(r_read);
      requires valid_regindex(r_write);
      requires (observer == k_mem_observer_t   || 
                observer == k_cache_observer_t ||
                observer == k_pt_observer_t);

      requires valid_cache_way_index(s_way);
      requires valid_cache_way_index(l_way);

      
      ensures (op == tap_proof_op_compute) ==> 
                  (cpu_enclave_id == old(cpu_enclave_id) &&
                   tap_enclave_metadata_valid == old(tap_enclave_metadata_valid) &&
                   tap_enclave_metadata_addr_excl == old(tap_enclave_metadata_addr_excl));




      modifies untrusted_addr_valid;
      modifies untrusted_addr_map;
      modifies untrusted_regs;
      modifies untrusted_pc;
      modifies tap_enclave_metadata_valid;
      modifies tap_enclave_metadata_addr_map;
      modifies tap_enclave_metadata_addr_valid;
      modifies tap_enclave_metadata_addr_excl;
      modifies tap_enclave_metadata_entrypoint;
      modifies tap_enclave_metadata_pc;
      modifies tap_enclave_metadata_regs;
      modifies tap_enclave_metadata_paused;
      modifies tap_enclave_metadata_cache_conflict;
      modifies cache_valid_map, cache_tag_map;
      modifies cpu_mem;
      modifies cpu_enclave_id;
      modifies cpu_addr_map;
      modifies cpu_addr_valid;
      modifies cpu_pc;
      modifies cpu_regs;
      modifies cpu_owner_map;
  {
      // "default" for the next mode.
      next_mode = mode;
      // "default" for whether we kill enclave eid.
      enclave_dead = false;

      // start with a dummy observation.
      observation = k0_word_t;
      status = enclave_op_success;
      havoc excp_1;
      havoc excp_2;
      assume (excp_1 != excp_none);
      assume (excp_2 != excp_none);
      hit_1 = false;
      hit_2 = false;

      case
      (op == tap_proof_op_compute) : {
          case
          (observer == k_mem_observer_t) : {
              call (observation) = MemObserverComputation(r_pc, r_read, r_write, r_data,
                                                         l_vaddr, s_vaddr, s_data,
                                                         r_pt_eid, r_pt_va,
                                                         pt_eid, pt_vaddr, pt_valid, pt_paddr);
          } 
          (observer == k_cache_observer_t) : {
              call (observation, hit_1, hit_2, excp_1, excp_2) = CacheObserverComputation(r_pc, r_read, r_write, r_data,
                                                           l_vaddr, s_vaddr, s_data,
                                                           r_pt_eid, r_pt_va,
                                                           pt_eid, pt_vaddr, pt_valid, pt_paddr,
                                                           l_way, s_way);
          } 
          (observer == k_pt_observer_t) : {
              call (observation, excp_1) = PTObserverComputation(r_pc, r_read, r_write, r_data,
                                                        l_vaddr, s_vaddr, s_data,
                                                        r_pt_eid, r_pt_va,
                                                        pt_eid, pt_vaddr, pt_valid, pt_paddr);
              assert (block_os_ev_read && (tap_enclave_metadata_addr_excl[r_pt_eid])[r_pt_va])
              ==> (observation == uf_observation_pt(k0_addr_perm_t, k0_wap_addr_t));
              assert (cpu_enclave_id != tap_null_enc_id || !tap_enclave_metadata_valid[r_pt_eid])
              ==> (observation == uf_observation_pt(k0_addr_perm_t, k0_wap_addr_t));

          }
          esac
      } 
      (op == tap_proof_op_launch) : {
          // can't put current pc inside the enclave.
          assume !r_excl_map[cpu_addr_map[cpu_pc]];
          call InitOSMem(r_container_valid, r_container_data);
          call (status) = launch(r_eid, r_addr_valid, r_addr_map, 
                                r_excl_vaddr, r_excl_map, r_entrypoint);
          assert (r_eid == eid) ==> (status != enclave_op_success);
      } 
      (op == tap_proof_op_destroy) : {
          call (status) = destroy(r_eid);
          // the enclave has been destroyed.
          if (r_eid == eid && status == enclave_op_success) {
              enclave_dead = true;
          }
      } 
      (op == tap_proof_op_enter) : {
          call (status) = enter(r_eid);
          assert (cpu_enclave_id == tap_null_enc_id && r_eid == eid) ==> 
                  (status == enclave_op_success);
          // switch to enclave mode.
          if (r_eid == eid && status == enclave_op_success) {
              next_mode = mode_enclave;
          }
      } 
      (op == tap_proof_op_exit) : {
          call (status) = exit();
      } 
      (op == tap_proof_op_resume) : {
          call (status) = resume(r_eid);
          // switch to enclave mode.
          assert (cpu_enclave_id == tap_null_enc_id && r_eid == eid && tap_enclave_metadata_paused[eid]) ==> 
                  (status == enclave_op_success);
          if (r_eid == eid && status == enclave_op_success) {
              next_mode = mode_enclave;
          }
      } 
      (op == tap_proof_op_pause) : {
          call (status) = pause();
      } 
      (op == tap_proof_op_release) : {
          call (status) = release_blocked_memory(r_bmap);
      } 
      (op == tap_proof_op_block) : {
          call (status) = block_memory_region(r_bmap);
      }
      esac
  }

  procedure [inline] EnclaveStep(
      /* Current mode */      mode              : mode_t,
      /* Secret Enclave */    eid               : tap_enclave_id_t,
      /* Operation. */        op                : tap_proof_op_t)

      returns (
          /* mode     */  next_mode : mode_t, 
          /* read     */  load_addr : vaddr_t, l_way : cache_way_index_t,
          /* store    */  store_addr : vaddr_t, store_data : word_t, s_way : cache_way_index_t
      )
      //modifies tap_enclave_metadata_valid;
      modifies tap_enclave_metadata_addr_map;
      modifies tap_enclave_metadata_addr_valid;
      modifies tap_enclave_metadata_addr_excl;
      modifies tap_enclave_metadata_pc;
      modifies tap_enclave_metadata_regs;
      modifies tap_enclave_metadata_paused;
      modifies tap_enclave_metadata_cache_conflict;
      modifies cache_valid_map, cache_tag_map;
      modifies cpu_pc;
      modifies cpu_regs;
      modifies cpu_mem;
      modifies cpu_enclave_id;
      modifies cpu_addr_map;
      modifies cpu_addr_valid;
  {
      var vaddr  : vaddr_t;
      var word   : word_t;
      var excp   : exception_t;
      var status : enclave_op_result_t;
      var hit    : boolean;
      var owner  : tap_enclave_id_t;
      var way    : cache_way_index_t;

      case
      (op == tap_proof_op_compute) : {
          // do whatever.
          call havoc_cpu_pc();
          call havoc_cpu_regs();

          // fetch from whereever inside the enclave.
          assume tap_enclave_metadata_addr_excl[eid][cpu_pc];
          assume tap_addr_perm_x(cpu_addr_valid[cpu_pc]);
          assert cpu_owner_map[cpu_addr_map[cpu_pc]] == eid;
          havoc way; assume valid_cache_way_index(way);
          call (word, excp, hit) = fetch_va(cpu_pc, way);
          assert (excp == excp_none);

          // load from whereever inside the enclave.
          havoc load_addr;
          assume tap_addr_perm_r(cpu_addr_valid[load_addr]);
          owner = cpu_owner_map[cpu_addr_map[load_addr]];
          assume owner == eid || owner == tap_null_enc_id;
          havoc l_way; assume valid_cache_way_index(l_way);
          call (word, excp, hit) = load_va(load_addr, l_way);
          assert (excp == excp_none);

          // store whatever inside the enclave.
          havoc store_addr; havoc store_data;
          assume tap_addr_perm_w(cpu_addr_valid[store_addr]);
          owner = cpu_owner_map[cpu_addr_map[store_addr]];
          assume owner == eid || owner == tap_null_enc_id;
          havoc s_way; assume valid_cache_way_index(s_way);
          call (excp, hit) = store_va(store_addr, store_data, s_way);
          assert excp == excp_none;
          store_data = store_data;

          // stay in the same mode.
          next_mode = mode;
      } 
      (op == tap_proof_op_exit) : {
          call (status) = exit();
          assert status == enclave_op_success;
          // switch back to the observer. 
          next_mode = mode_untrusted;
      } 
      (op == tap_proof_op_pause) : {
          //call (status) = exit();
          call (status) = pause();
          assert status == enclave_op_success;
          // switch back to the observer. 
          next_mode = mode_untrusted;
      }
      esac
  }

  procedure [inline] SetInitState(
    _cpu_mem : mem_t,
    _cpu_regs : regs_t,
    _cpu_pc : vaddr_t,
    _cpu_enclave_id : tap_enclave_id_t,
    _cpu_addr_valid : addr_valid_t,
    _cpu_addr_map : addr_map_t,
    _cpu_owner_map : owner_map_t,
    _cache_valid_map : cache_valid_map_t,
    _cache_tag_map : cache_tag_map_t,
    _untrusted_addr_valid : addr_valid_t,
    _untrusted_addr_map : addr_map_t,
    _untrusted_regs : regs_t,
    _untrusted_pc : vaddr_t,
    _tap_enclave_metadata_valid : tap_enclave_metadata_valid_t,
    _tap_enclave_metadata_addr_map : tap_enclave_metadata_addr_map_t,
    _tap_enclave_metadata_addr_valid : tap_enclave_metadata_addr_valid_t,
    _tap_enclave_metadata_addr_excl : tap_enclave_metadata_addr_excl_t,
    _tap_enclave_metadata_entrypoint : tap_enclave_metadata_entrypoint_t,
    _tap_enclave_metadata_pc : tap_enclave_metadata_pc_t,
    _tap_enclave_metadata_regs : tap_enclave_metadata_regs_t,
    _tap_enclave_metadata_paused : tap_enclave_metadata_paused_t,
    _tap_enclave_metadata_cache_conflict : tap_enclave_metadata_cache_conflict_t
  )
    modifies untrusted_addr_valid;
    modifies untrusted_addr_map;
    modifies untrusted_regs;
    modifies untrusted_pc;
    modifies tap_enclave_metadata_valid;
    modifies tap_enclave_metadata_addr_map;
    modifies tap_enclave_metadata_addr_valid;
    modifies tap_enclave_metadata_addr_excl;
    modifies tap_enclave_metadata_entrypoint;
    modifies tap_enclave_metadata_pc;
    modifies tap_enclave_metadata_regs;
    modifies tap_enclave_metadata_paused;
    modifies tap_enclave_metadata_cache_conflict;
    modifies cpu_enclave_id;
    modifies cpu_addr_map;
    modifies cpu_addr_valid;
    modifies cpu_pc;
    modifies cpu_regs;
    modifies cpu_owner_map;
    modifies cpu_mem;
    modifies cache_valid_map, cache_tag_map;
  {
    untrusted_addr_valid                = _untrusted_addr_valid;
    untrusted_addr_map                  = _untrusted_addr_map;
    untrusted_regs                      = _untrusted_regs;
    untrusted_pc                        = _untrusted_pc;
    tap_enclave_metadata_valid          = _tap_enclave_metadata_valid;
    tap_enclave_metadata_addr_map       = _tap_enclave_metadata_addr_map;
    tap_enclave_metadata_addr_valid     = _tap_enclave_metadata_addr_valid;
    tap_enclave_metadata_addr_excl      = _tap_enclave_metadata_addr_excl;
    tap_enclave_metadata_entrypoint     = _tap_enclave_metadata_entrypoint;
    tap_enclave_metadata_pc             = _tap_enclave_metadata_pc;
    tap_enclave_metadata_regs           = _tap_enclave_metadata_regs;
    tap_enclave_metadata_paused         = _tap_enclave_metadata_paused;
    tap_enclave_metadata_cache_conflict = _tap_enclave_metadata_cache_conflict;
    call set_cpu_state(_cpu_enclave_id,
                           _cpu_addr_map,
                           _cpu_addr_valid,
                           _cpu_pc,
                           _cpu_regs);
    call set_cpu_owner_map(_cpu_owner_map);
    call set_cpu_mem(_cpu_mem);
    call set_cache(_cache_valid_map, _cache_tag_map);
  }

  //======================================================================//
  // END OF PROOF PROCEDURES                                              //
  //======================================================================//

  init {
    // Initialization of the TAP model should happen at the proof
    // level depending on the initial conditions.
    tap_current_mode = mode_untrusted;
    tap_enclave_dead = false;
    tap_vaddr = k0_vaddr_t;
    tap_paddr = k0_wap_addr_t;
    tap_data = k0_word_t;
  }

  next {
    case
      (tap_current_mode == mode_untrusted) : {
        call (tap_current_mode', tap_enclave_dead') =
          IntegrityAdversarialStep(tap_current_mode, tap_eid, tap_r_eid, tap_r_regs, tap_r_proof_op);
      }
      (tap_current_mode == mode_enclave) : {
        call (tap_current_mode', tap_vaddr', tap_paddr', tap_data') =
          IntegrityEnclaveStep(tap_e_proof_op, tap_iter);
      }
    esac
  }

  control {
    set_solver_option(":mbqi", false);
    set_solver_option(":case_split", 0);
    set_solver_option(":relevancy", 0);
    set_solver_option(":threads", 4);
    set_solver_option(":blast_full", true);

    paddr_conflict_verif = verify(does_paddr_conflict);                     //passes
    enclave_conflict_verif = verify(does_enclave_conflict);                 //passes
    set_addr_map_verif = verify(set_addr_map);                              //no assertions to check
    get_enclave_addr_map_verif = verify(get_enclave_addr_map);              //no assertions to check
    set_enclave_addr_map_verif = verify(set_enclave_addr_map);              //no assertions to check
    tap_init_verif = verify(initialize_tap);                                //passes
    launch_verif = verify(launch);                                          //passes
    enter_verif  = verify(enter);                                           //passes
    resume_verif = verify(resume);                                          //passes
    exit_verif   = verify(exit);                                            //passes
    pause_verif  = verify(pause);                                           //passes
    destroy_verif = verify(destroy);                                        //passes
    block_memory_verif = verify(block_memory_region);                       //passes
    release_memory_verif = verify(release_blocked_memory);                  //passes
    tap_addr_valid_proofs_verif = verify(tap_addr_valid_proofs);            //passes
    init_havoc_verif = verify(InitialHavoc);                                //passes                            
    
    check;
    print_results;
  }
}